<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="希望自己在未来的路上越走越坚定."><title>reactivecocoa深入学习 | aSnail</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">reactivecocoa深入学习</h1><a id="logo" href="/.">aSnail</a><p class="description">年轻就是折腾</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">reactivecocoa深入学习</h1><div class="post-meta">Nov 15, 2015<span> | </span><span class="category"><a href="/categories/iOSTips/">iOSTips</a></span></div><a class="disqus-comment-count" data-disqus-identifier="2015/11/15/reactivecocoa深入学习/" href="/2015/11/15/reactivecocoa深入学习/#disqus_thread"></a><div class="post-content"><h2 id="ReactiveCocoa"><a href="#ReactiveCocoa" class="headerlink" title="ReactiveCocoa"></a>ReactiveCocoa</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li>在 <strong>iOS</strong> 编程中我们需要处理各种事件,例如响应按钮的点击,监听键盘的输入,监听网络回包等…我们通常使用<code>Cocoa</code>推荐的例如<code>target-action</code>、<code>delegate</code>、<code>key-value observing</code>、<code>callback</code>等。</li>
<li><strong>ReactiveCocoa</strong>为我们提供了一种统一化的解决此类问题的方式,使用RAC解决问题，就不需要考虑调用顺序，直接考虑结果，把每一次操作都写成一系列嵌套的方法中，使代码高聚合，方便管理。</li>
<li><strong>ReactiveCocoa</strong>将所有<code>Cocoa</code>中的事件都定义为了信号(single)，从而可以使用一些基本工具来更容易的连接、过滤和组合.</li>
</ul>
<h3 id="RAC中涉及到的编程思想"><a href="#RAC中涉及到的编程思想" class="headerlink" title="RAC中涉及到的编程思想:"></a>RAC中涉及到的编程思想:</h3><ul>
<li><p><strong>函数式编程</strong>（<a href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="noopener">functional programming</a>）：使用高阶函数，例如函数用其他函数作为参数。</p>
</li>
<li><p><strong>响应式编程</strong>（<a href="https://en.wikipedia.org/wiki/Reactive_programming" target="_blank" rel="noopener">reactive programming</a>）：关注于数据流和变化传播。不需要考虑事件的调用过程,只需要关注数据的流入和输出.</p>
</li>
</ul>
<blockquote>
<p> 所以，你可能听说过reactivecocoa被描述为<a href="https://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank" rel="noopener">函数响应式编程</a><a href="https://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank" rel="noopener">FRP</a>框架。<br>其他平台上也有类似的框架例如java的 <strong>RXJava</strong>  swift中的<strong>ReactiveSwif</strong></p>
</blockquote>
<ul>
<li><strong>链式编程</strong> : 是将多个操作（多行代码）通过点号.链接在一起成为一句代码,使代码可读性好。注意点:要想达到链式编程方法的返回值必须是一个(返回值是本身对象的)<code>block</code>),典型代表就是<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener">Masonry</a>框架</li>
</ul>
<hr>
<h3 id="RAC框架的结构-直接略过"><a href="#RAC框架的结构-直接略过" class="headerlink" title="RAC框架的结构(直接略过)"></a>RAC框架的结构(直接略过)</h3><p><img src="http://blog.leichunfeng.com/images/ReactiveCocoa%20v2.5.png" alt></p>
<h3 id="RAC中重要的类"><a href="#RAC中重要的类" class="headerlink" title="RAC中重要的类"></a>RAC中重要的类</h3><h4 id="RAC最重要的类是RACSingle-信号类"><a href="#RAC最重要的类是RACSingle-信号类" class="headerlink" title="RAC最重要的类是RACSingle(信号类)"></a>RAC最重要的类是<strong>RACSingle</strong>(信号类)</h4><ul>
<li>它本身不具备发送信号的能力，而是交给内部一个订阅者(<code>id &lt;RACSubscriber&gt;</code>)去发出。</li>
<li>默认一个信号创建出来都是冷信号，即使是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了就会触发</li>
<li>RACSignal的每个操作都会返回一个RACsignal，这在术语上叫做连贯接口（fluent interface）,从而实现 <code>链式编程</code></li>
</ul>
<hr>
<blockquote>
<p>所以这里着重介绍一下RACSingle的创建和订阅的实现,从而理解信号的创建以及数据的传递过程</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里用到一个工厂方法将子类实例返回回去</span></span><br><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line"> <span class="keyword">return</span> [RACDynamicSignal createSignal:didSubscribe];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们再来看看子类`RACDynamicSignal`中的具体实现,其实就是吧传递过来的didSubscribe这个block保存起来</span></span><br><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line"> RACDynamicSignal *signal = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line"> signal-&gt;_didSubscribe = [didSubscribe <span class="keyword">copy</span>];</span><br><span class="line"> <span class="keyword">return</span> [signal setNameWithFormat:<span class="string">@"+createSignal:"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法的参数<code>didSubscribe</code>这个block 可以理解为是对信号的描述,<br>上面只是信号的创建过程,上面提到了默认信号被创建出来以后只是冷信号,也就是<strong>didSubscribe</strong>这个block只有当RACSingle调用subscribeNext:方法是才会调用,方法里的subscriber有三种方法,也可以理解为可以发送三种信号分别为:<strong>next</strong>、<strong>error</strong>、<strong>completed</strong>,<br>其中<code>sendNext()</code>是发送我们需要传递的对象,<code>sendError</code>,和<code>sendComplete</code>都会中断信号的订阅.不同的是<code>sendError</code>会传递一个错误值<code>error</code>.一个<code>signal</code>在因<code>error</code>终止或者<code>sendComplete</code>前，可以发送任意数量的<code>next</code>事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock;</span><br></pre></td></tr></table></figure>
<p>下面我们再来看看:subscribeNext:方法的实现过程:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribeNext:(<span class="keyword">void</span> (^)(id x))nextBlock &#123;</span><br><span class="line"> NSCParameterAssert(nextBlock != <span class="literal">NULL</span>);</span><br><span class="line"> RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock </span><br><span class="line">                                                error:<span class="literal">NULL</span> </span><br><span class="line">                                            completed:<span class="literal">NULL</span>];</span><br><span class="line"> <span class="keyword">return</span> [self subscribe:o];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先创建一个RACSubscriber对象,这个是遵守了RACSubscriber协议的<strong>RACSubscriber *</strong>类型的对象,这个对象会将传递进来的nextBlock保存起来(也是保存成成员变量),当创建对象时候的didSubscribe中的”subscriber”调用sendNext:的时候nextBlock就会被调用! 有点绕,这里只是介绍了其中大概的工作原理,其中还有RACScheduler的参与,这里就不做介绍了..</p>
<h4 id="RAC为cocoa中的很多类通过分类的形式快速生成信号以及常见的宏使用"><a href="#RAC为cocoa中的很多类通过分类的形式快速生成信号以及常见的宏使用" class="headerlink" title="RAC为cocoa中的很多类通过分类的形式快速生成信号以及常见的宏使用:"></a>RAC为cocoa中的很多类通过分类的形式快速生成信号以及常见的宏使用:</h4><p><strong>@weakify(self) &amp; @strongify(self)</strong>: <em>Weak &amp; Strong dance</em></p>
<p><strong>RACObserve(TARGET, KEYPATH) &amp; RAC(TARGET, …)</strong> :这对宏简直是绝配类似<strong>KVC</strong>的用法,能够快速地实现对象属性的映射</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//e.g.</span><br><span class="line">RAC(self.titleLabel,text) = [RACObserve(self.viewModel, title);</span><br></pre></td></tr></table></figure>
<p><strong>rac_signalForSelector</strong> : 执行某一个方法就会生成信号</p>
<p><strong>rac_valuesAndChangesForKeyPath</strong>：用于监听某个对象的属性改变。</p>
<p><strong>rac_signalForControlEvents</strong>:替代<em>UIControl</em>中的<em>Target</em>模式</p>
<p><strong>rac_addObserverForName</strong>用于监听某个通知。</p>
<p><strong>RACTuplePack(…)</strong>快速包装成元祖类,成对出现的有RACTupleUnpack(…)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RACTuple *tuple = RACTuplePack(@&quot;xmg&quot;,@20); </span><br><span class="line">RACTupleUnpack(NSString *name,NSNumber *age) = tuple;</span><br></pre></td></tr></table></figure>
<p><strong>rac_liftSelector:withSignalsFromArray:Signals:</strong></p>
<blockquote>
<p>应用场景: 当界面有多个请求的时候,当所有的请求都回包时才出发某个操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;  RACSignal *request1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">&gt;      // 发送请求1 ,并且获取到数据以后:</span><br><span class="line">&gt;     [subscriber sendNext:@&quot;发送请求1&quot;];</span><br><span class="line">&gt;      return nil; </span><br><span class="line">&gt; &#125;];</span><br><span class="line">&gt;  RACSignal *request2 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">&gt;      // 发送请求2 ,并且获取到数据以后:</span><br><span class="line">&gt;     [subscriber sendNext:@&quot;发送请求2&quot;];</span><br><span class="line">&gt;      return nil; </span><br><span class="line">&gt; &#125;]; </span><br><span class="line">&gt; // 使用注意：updateUIWithR1::中的参数和信号所传递过来的数据一一对应</span><br><span class="line">&gt;  [self rac_liftSelector:@selector(updateUIWithR1:r2:) withSignalsFromArray:@[request1,request2]];</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="RACSubject类"><a href="#RACSubject类" class="headerlink" title="RACSubject类"></a>RACSubject类</h4><ul>
<li><p><em>RACSubject</em>既是信号(继承自<em>RACSingle</em>类),又是订阅者(遵循<code>&lt;RACSubscriber&gt;</code>),通常使用<em>RACSubject</em>类来代替代理,其实我感觉代替通知都可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">[subject subscribeNext:^(id x) &#123; </span><br><span class="line">   NSLog(@&quot;第一个订阅者%@&quot;,x); </span><br><span class="line">&#125;];</span><br><span class="line">[subject subscribeNext:^(id x) &#123;</span><br><span class="line">   NSLog(@&quot;第二个订阅者%@&quot;,x); </span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@&quot;1&quot;];</span><br></pre></td></tr></table></figure>
</li>
<li><p><em>RACReplaySubject</em>:重复提供信号类，RACSubject的子类。</p>
</li>
</ul>
<p><strong><em>RACReplaySubject与RACSubject区别</em></strong>: RACReplaySubject可以先发送信号，在订阅信号，RACSubject就不可以。如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。</p>
<h4 id="RAC中的集合类RACSequence"><a href="#RAC中的集合类RACSequence" class="headerlink" title="RAC中的集合类RACSequence"></a>RAC中的集合类RACSequence</h4><p><strong>RACSequence</strong>是RAC中的集合类,可以实现OC对象与信号中传递值之间的转换,RAC类库中提供了NSArray,NSDictionary等集合类的分类供其转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//遍历数组</span><br><span class="line">NSArray *numbers = @[@1,@2,@3,@4]; </span><br><span class="line">[numbers.rac_sequence.signal subscribeNext:^(id x) &#123;</span><br><span class="line">     NSLog(@&quot;%@&quot;,x);</span><br><span class="line"> &#125;];</span><br><span class="line"></span><br><span class="line">//遍历字典</span><br><span class="line">NSDictionary *dict = @&#123;@&quot;name&quot;:@&quot;qdaily&quot;,@&quot;age&quot;:@3&#125;;</span><br><span class="line"> [dict.rac_sequence.signal subscribeNext:^(RACTuple *x) &#123; </span><br><span class="line">       RACTupleUnpack(NSString *key,NSString *value) = x; </span><br><span class="line">       NSLog(@&quot;%@ %@&quot;,key,value); </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><strong>RACTupleUnpack</strong>将RACTuple进行解包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//使用map方法可以快速进行字典转模型</span><br><span class="line">NSArray *flags = [[dictArr.rac_sequence map:^id(id value) &#123;</span><br><span class="line">     return [FlagItem flagWithDict:value]; </span><br><span class="line">&#125;] array];</span><br></pre></td></tr></table></figure>
<h4 id="RACCommand-RAC中用于处理事件的类"><a href="#RACCommand-RAC中用于处理事件的类" class="headerlink" title="RACCommand:RAC中用于处理事件的类"></a>RACCommand:RAC中用于处理事件的类</h4><blockquote>
<p>可以理解为命令类,是对信号和事件的封装</p>
</blockquote>
<p>使用场景:监听按钮点击，网络请求<br><em>RACCommand</em>使用注意点:</p>
<ol>
<li>signalBlock必须要返回一个信号，不能传nil. </li>
<li>如果不想要传递信号，直接创建空的信号[RACSignal empty]; </li>
<li>RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。 </li>
<li>RACCommand需要被强引用，否则接收不到RACCommand中的信号，因此RACCommand中的信号是延迟发送的。</li>
</ol>
<p>RACCommand简单使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> RACCommand *requestCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123;</span><br><span class="line">     NSLog(@&quot;请求数据ing...&quot;); </span><br><span class="line">    //这里即使不需要传递值也要创建空的信号而不能返回nil</span><br><span class="line">    //    return [RACSignal empty]; </span><br><span class="line">     return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@&quot;请求数据&quot;];</span><br><span class="line">         // 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。 </span><br><span class="line">        [subscriber sendCompleted]; return nil; </span><br><span class="line">    &#125;];</span><br><span class="line"> &#125;];</span><br><span class="line"> // 强引用命令，不要被销毁，否则接收不到数据,这个command属性一般暴露给外界</span><br><span class="line"> _conmmand = command;</span><br><span class="line"></span><br><span class="line">//下面通常是外面调用</span><br><span class="line"> [command.executionSignals subscribeNext:^(id x) &#123; </span><br><span class="line">    [x subscribeNext:^(id x) &#123;</span><br><span class="line">         NSLog(@&quot;网络获取的值是:%@&quot;,x);</span><br><span class="line">     &#125;];</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// RACCommand高级用法 </span><br><span class="line">// switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号 [command.executionSignals.switchToLatest subscribeNext:^(id x) &#123;                          </span><br><span class="line">    NSLog(@&quot;%@&quot;,x);</span><br><span class="line"> &#125;];</span><br><span class="line"></span><br><span class="line"> //executing 监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。</span><br><span class="line"> [[command.executing skip:1] subscribeNext:^(id x) &#123; </span><br><span class="line">    if ([x boolValue] == YES) &#123;</span><br><span class="line">         // 正在执行 NSLog(@&quot;正在执行&quot;); </span><br><span class="line">    &#125;else&#123; </span><br><span class="line">        // 执行完成 NSLog(@&quot;执行完成&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure>
<h4 id="RACMuticastConnection"><a href="#RACMuticastConnection" class="headerlink" title="RACMuticastConnection"></a>RACMuticastConnection</h4><blockquote>
<p>RACMulticastConnection:用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。</p>
</blockquote>
<ul>
<li><p>普通的订阅信号过程:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   NSLog(@&quot;发送请求&quot;);</span><br><span class="line">   return nil;</span><br><span class="line">&#125;];</span><br><span class="line">// 第一次订阅信号 </span><br><span class="line">[signal subscribeNext:^(id x) &#123;</span><br><span class="line">   NSLog(@&quot;接收数据&quot;); </span><br><span class="line">&#125;]; </span><br><span class="line">//  第二次订阅信号 </span><br><span class="line">[signal subscribeNext:^(id x) &#123;</span><br><span class="line">   NSLog(@&quot;接收数据&quot;);</span><br><span class="line">&#125;]; </span><br><span class="line">// 3.运行结果:打印两次@&quot;发送请求&quot;，也就是每次订阅都会发送一次请求</span><br></pre></td></tr></table></figure>
</li>
<li><p>RACMulticastConnection:解决重复请求问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   NSLog(@&quot;发送请求&quot;); </span><br><span class="line">  [subscriber sendNext:@1];</span><br><span class="line">       return nil; </span><br><span class="line">  &#125;]; </span><br><span class="line"></span><br><span class="line">RACMulticastConnection *connect = [signal publish];</span><br><span class="line"></span><br><span class="line">// 注意：订阅信号，也不能激活信号，只是保存订阅者到数组，必须通过连接,当调用连接，就会一次性调用所有订阅者的sendNext: </span><br><span class="line">[connect.signal subscribeNext:^(id x) &#123; </span><br><span class="line">  NSLog(@&quot;订阅者一信号&quot;);</span><br><span class="line">&#125;];</span><br><span class="line">[connect.signal subscribeNext:^(id x) &#123;</span><br><span class="line">   NSLog(@&quot;订阅者二信号&quot;); </span><br><span class="line">&#125;]; </span><br><span class="line">[connect connect];</span><br><span class="line">//运行结果:只会打印一次@&quot;发送请求&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="RAC中信号处理的常用方法"><a href="#RAC中信号处理的常用方法" class="headerlink" title="RAC中信号处理的常用方法"></a>RAC中信号处理的常用方法</h3><h4 id="RAC-核心方法绑定bind"><a href="#RAC-核心方法绑定bind" class="headerlink" title="RAC 核心方法绑定bind"></a>RAC 核心方法绑定<code>bind</code></h4><p>对比之前的开发方式是赋值，而用RAC开发，应该把重心放在绑定，也就是在创建一个对象的时候，就绑定好以后想要做的事情，而不是等赋值之后在去做事情。<br>列如：把数据展示到控件上，之前都是重写控件的setModel方法，用RAC就可以在一开始创建控件的时候，就绑定好数据。</p>
<blockquote>
<p><strong>注意:</strong>在开发中很少使用<code>bind</code>方法，<code>bind</code>属于RAC中的底层方法，RAC已经封装了很多好用的其他方法，底层都是调用bind，用法比bind简单.</p>
</blockquote>
<p>下面例子中要实现当 <em>testField</em> 的文字改变以后每次输出”输出:**“,下面的信号订阅方法底层会转换成bind方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 bind 方法</span></span><br><span class="line">[[_textField.rac_textSignal bind:^RACStreamBindBlock&#123;</span><br><span class="line">        <span class="keyword">return</span> ^RACStream *(<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop)&#123;</span><br><span class="line">            <span class="keyword">return</span> [RACReturnSignal <span class="keyword">return</span>:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"输出:%@"</span>,value]];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//直接订阅信号</span><br><span class="line">[_textField.rac_textSignal subscribeNext:^(id x) &#123; NSLog(@&quot;输出:%@&quot;,x); &#125;];</span><br></pre></td></tr></table></figure>
<h3 id="过滤信号的操作"><a href="#过滤信号的操作" class="headerlink" title="过滤信号的操作"></a>过滤信号的操作</h3><h4 id="fliter-过滤信号-条件过滤"><a href="#fliter-过滤信号-条件过滤" class="headerlink" title="fliter : 过滤信号(条件过滤)"></a>fliter : 过滤信号(条件过滤)</h4><blockquote>
<ul>
<li>通过返回<strong>bool</strong>的方式控制是否接受信号传递过来的值(控制是否调用<code>subscribeNext</code>这个block)</li>
<li>fliter会将接受的信号通过返回的条件进行筛选,并且生成新的信号供订阅者订阅.</li>
<li>从fliter的使用中可以看出<code>RAC</code>中对信号的操作都会生成新的信号,以便达到链式编程的目的</li>
<li>从这点建议在对信号的操作的代码书写规范:每一次操作都应该折行,这样阅读起来更加清晰</li>
</ul>
</blockquote>
<p>本例中要实现当用户名长度大于3的时候输出log</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="keyword">self</span>.usernameTextField.rac_textSignal</span><br><span class="line">     filter:^<span class="built_in">BOOL</span>(<span class="keyword">id</span> value)&#123;</span><br><span class="line">        <span class="built_in">NSString</span>*text = value;</span><br><span class="line">        <span class="keyword">return</span> text.length &gt; <span class="number">3</span>;</span><br><span class="line">&#125;] subscribeNext:^(<span class="keyword">id</span> x)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<h4 id="ignore"><a href="#ignore" class="headerlink" title="ignore:"></a>ignore:</h4><blockquote>
<p>忽略某些信号的值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 内部调用filter过滤，忽略掉ignore的值 [[_textField.rac_textSignal ignore:@&quot;1&quot;]     </span><br><span class="line">    subscribeNext:^(id x) &#123;</span><br><span class="line">         NSLog(@&quot;%@&quot;,x); </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="distinctUntilChanged"><a href="#distinctUntilChanged" class="headerlink" title="distinctUntilChanged:"></a>distinctUntilChanged:</h4><blockquote>
<p>当上一次的值和当前的值有明显的变化就会发出信号, 在开发中，刷新UI经常使用，只有两次数据不一样才需要刷新,提高性能,减少不必要的操作</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[_textField.rac_textSignal distinctUntilChanged] subscribeNext:^(id x) &#123;</span><br><span class="line">   NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="take"><a href="#take" class="headerlink" title="take"></a>take</h4><blockquote>
<p>从信号发出的值中取前n个</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *signal = [RACSubject subject]; </span><br><span class="line">[[signal take:1] subscribeNext:^(id x) &#123;</span><br><span class="line">     NSLog(@&quot;%@&quot;,x); </span><br><span class="line">&#125;];</span><br><span class="line">[signal sendNext:@1]; </span><br><span class="line">[signal sendNext:@2];</span><br></pre></td></tr></table></figure>
<h4 id="takeLast"><a href="#takeLast" class="headerlink" title="takeLast:"></a>takeLast:</h4><blockquote>
<p>取最后N次的信号,前提条件，由于是从信号的后面取,所以订阅者必须调用完成，因为只有完成，就知道总共有多少信号.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *signal = [RACSubject subject];</span><br><span class="line">[[signal takeLast:1] subscribeNext:^(id x) </span><br><span class="line">   NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line">[signal sendNext:@1];</span><br><span class="line">[signal sendNext:@2];</span><br><span class="line">//必须有下一步!</span><br><span class="line">[signal sendCompleted];</span><br></pre></td></tr></table></figure>
<h4 id="takeUntil-RACSignal"><a href="#takeUntil-RACSignal" class="headerlink" title="takeUntil:(RACSignal *):"></a>takeUntil:(RACSignal *):</h4><blockquote>
<p>获取信号直到某个信号执行完成</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[_textField.rac_textSignal </span><br><span class="line">    takeUntil:self.rac_willDeallocSignal];</span><br></pre></td></tr></table></figure>
<h4 id="skip-NSUInteger"><a href="#skip-NSUInteger" class="headerlink" title="skip:(NSUInteger):"></a>skip:(NSUInteger):</h4><blockquote>
<p>跳过几个信号,不接受。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 表示输入第一次，不会被监听到，跳过第一次发出的信号</span><br><span class="line">[[_textField.rac_textSignal skip:1] subscribeNext:^(id x) &#123;</span><br><span class="line">       NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="switchToLatest"><a href="#switchToLatest" class="headerlink" title="switchToLatest:"></a>switchToLatest:</h4><blockquote>
<p>用于signalOfSignals（信号的信号），有时候信号也会发出信号，会在signalOfSignals中，获取signalOfSignals发送的最新信号。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *signalOfSignals = [RACSubject subject];</span><br><span class="line">RACSubject *signal = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">// 获取信号中信号最近发出信号，订阅最近发出的信号。</span><br><span class="line">// 注意switchToLatest：只能用于信号中的信号</span><br><span class="line">[signalOfSignals.switchToLatest subscribeNext:^(id x) &#123;</span><br><span class="line"></span><br><span class="line">   NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line">[signalOfSignals sendNext:signal];</span><br><span class="line">[signal sendNext:@1];</span><br></pre></td></tr></table></figure>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map:"></a>Map:</h4><blockquote>
<p>(映射) map能够”加工信号传递的值”</p>
<p>这里的加工信号指的是将上一个next事件传递过来的信号值x进行<strong>加工</strong>或者<strong>转换</strong>成任意的OC对象,通过block返回值返回回去,这个例子中就是将用户名加工成NSNumber值返回回去,所以下一个next事件接收到的值就是NSNumber对象.</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[[[<span class="keyword">self</span>.usernameTextField.rac_textSignal</span><br><span class="line">  map:^<span class="keyword">id</span>(<span class="built_in">NSString</span>*text)&#123;</span><br><span class="line">    <span class="keyword">return</span> @(text.length);</span><br><span class="line">  &#125;]</span><br><span class="line">  filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSNumber</span>*length)&#123;</span><br><span class="line">    <span class="keyword">return</span>[length integerValue] &gt; <span class="number">3</span>;</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(<span class="keyword">id</span> x)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x):</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//test2</span></span><br><span class="line">[[validPasswordSignal</span><br><span class="line">map:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *passwordValid)&#123;</span><br><span class="line">    <span class="keyword">return</span>[passwordValid boolValue] ? [<span class="built_in">UIColor</span> clearColor]:[<span class="built_in">UIColor</span> yellowColor];</span><br><span class="line">&#125;]</span><br><span class="line">subscribeNext:^(<span class="built_in">UIColor</span> *color)&#123;</span><br><span class="line">    <span class="keyword">self</span>.passwordTextField.backgroundColor = color;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="flatten-map-信号的映射"><a href="#flatten-map-信号的映射" class="headerlink" title="flatten map: 信号的映射"></a>flatten map: 信号的映射</h4><blockquote>
<p>flatten可以对传递过来的信号进行加工,会重新新建一个信号,block中的返回值是一个信号</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> [[_textField.rac_textSignal flattenMap:^RACStream *(id value) &#123;</span><br><span class="line">     return [RACReturnSignal return:[NSString stringWithFormat:@&quot;输出:%@&quot;,value]]; &#125;]</span><br><span class="line">              subscribeNext:^(id x) &#123;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>flattenMap 和 Map 方法的区别:</p>
<ul>
<li>flattenMap方法中的block返回值是信号,所以是对信号的加工</li>
<li>Map 方法中的block的返回值是对象,是对信号传递的变量的加工</li>
<li>一般如果传递的是对象,使用map,信号传递的是信号就用flattenMap</li>
</ul>
<h4 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h4><blockquote>
<p>聚合: 将多个信号发出的值进行聚合</p>
</blockquote>
<p>常用用法:通常使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)combineLatest:(id&lt;NSFastEnumeration&gt;)signals reduce:(id (^)())reduceBlock;</span><br></pre></td></tr></table></figure>
<p>将多个信号进行聚合,在<code>reduceBlock</code>中将信号传递的<code>值</code>进行整合.这个方法会创建一个新的信号携带整合好的值返回,每次这两个源信号的任何一个产生新值时，reduce block都会执行，block的返回值会发给下一个信号。常见应用场景就是登录界面是否满足登录条件从而控制登录按钮的状态</p>
<blockquote>
<p>注意这个方法中的reduceBlock: 这个block是一个返回值为id类型的,也就是说我们将需要聚合的信号携带的值进行加工组合以后一定要返回一个新的对象,combineLatest::这个方法返回的信号会携带这个新对象! 我们再注意看<code>reduceBlock</code>中的参数,参数个数是不确定的,他们和信号中携带的值一一对应,为了实现这个功能RAC中专门有个<code>RACBlockTrampoline</code>类来处理这个逻辑</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"></span><br><span class="line">   [subscriber sendNext:@1];</span><br><span class="line"></span><br><span class="line">   return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"></span><br><span class="line">   [subscriber sendNext:@2];</span><br><span class="line"></span><br><span class="line">   return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *reduceSignal = [RACSignal combineLatest:@[signalA,signalB] reduce:^id(NSNumber *num1 ,NSNumber *num2)&#123;</span><br><span class="line"></span><br><span class="line">  return [NSString stringWithFormat:@&quot;%@ %@&quot;,num1,num2];</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[reduceSignal subscribeNext:^(id x) &#123;</span><br><span class="line"></span><br><span class="line">   NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="ReactiveCocoa操作方法之控制流操作"><a href="#ReactiveCocoa操作方法之控制流操作" class="headerlink" title="ReactiveCocoa操作方法之控制流操作"></a>ReactiveCocoa操作方法之控制流操作</h3><h4 id="doNext"><a href="#doNext" class="headerlink" title="doNext:"></a>doNext:</h4><blockquote>
<p>执行Next之前，会先执行这个Block</p>
</blockquote>
<h4 id="doCompleted"><a href="#doCompleted" class="headerlink" title="doCompleted:"></a>doCompleted:</h4><blockquote>
<p>执行sendCompleted之前，会先执行这个Block</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; </span><br><span class="line">    [subscriber sendNext:@1];</span><br><span class="line">     [subscriber sendCompleted]; </span><br><span class="line">    return nil;</span><br><span class="line"> &#125;] doNext:^(id x) &#123; </span><br><span class="line">    // 执行[subscriber sendNext:@1];之前会调用这个Block         </span><br><span class="line">    NSLog(@&quot;doNext&quot;);; </span><br><span class="line">&#125;] doCompleted:^&#123;</span><br><span class="line"> // 执行[subscriber sendCompleted];之前会调用这个Block </span><br><span class="line">    NSLog(@&quot;doCompleted&quot;);; &#125;] subscribeNext:^(id x) &#123;     </span><br><span class="line">    NSLog(@&quot;%@&quot;,x);</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure>
<h3 id="ReactiveCocoa中的线程操作"><a href="#ReactiveCocoa中的线程操作" class="headerlink" title="ReactiveCocoa中的线程操作"></a>ReactiveCocoa中的线程操作</h3><h4 id="deliverOn"><a href="#deliverOn" class="headerlink" title="deliverOn:"></a>deliverOn:</h4><blockquote>
<p>内容传递切换到指定线程中，副作用在原来线程中,把在创建信号时block中的代码称之为副作用。</p>
</blockquote>
<h4 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn:"></a>subscribeOn:</h4><blockquote>
<p>内容传递和副作用都会切换到指定线程中。</p>
</blockquote>
<h3 id="ReactiveCocoa操作方法之时间控制。"><a href="#ReactiveCocoa操作方法之时间控制。" class="headerlink" title="ReactiveCocoa操作方法之时间控制。"></a>ReactiveCocoa操作方法之<strong>时间控制</strong>。</h3><h4 id="timeout："><a href="#timeout：" class="headerlink" title="timeout："></a>timeout：</h4><blockquote>
<p>超时，可以让一个信号在一定的时间后，自动报错。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">     return nil; </span><br><span class="line">&#125;] timeout:1 onScheduler:[RACScheduler currentScheduler]];</span><br><span class="line"></span><br><span class="line">[signal subscribeNext:^(id x) &#123;</span><br><span class="line">     NSLog(@&quot;%@&quot;,x); </span><br><span class="line">&#125; error:^(NSError *error) &#123; </span><br><span class="line">    // 1秒后会自动调用</span><br><span class="line">     NSLog(@&quot;%@&quot;,error); </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="interval"><a href="#interval" class="headerlink" title="interval"></a>interval</h4><blockquote>
<p>定时：每隔一段时间发出信号</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[RACSignal interval:1 onScheduler:[RACScheduler currentScheduler]] subscribeNext:^(id x) &#123;</span><br><span class="line">     NSLog(@&quot;%@&quot;,x);</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure>
<h4 id="delay"><a href="#delay" class="headerlink" title="delay"></a>delay</h4><blockquote>
<p>延迟发送next。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; </span><br><span class="line">   [subscriber sendNext:@1]; </span><br><span class="line">   return nil;</span><br><span class="line">&#125;] delay:2] subscribeNext:^(id x) &#123; </span><br><span class="line">   NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="ReactiveCocoa操作方法之重复。"><a href="#ReactiveCocoa操作方法之重复。" class="headerlink" title="ReactiveCocoa操作方法之重复。"></a>ReactiveCocoa操作方法之重复。</h3><h4 id="retry"><a href="#retry" class="headerlink" title="retry"></a>retry</h4><blockquote>
<p>重试 ：只要失败，就会重新执行创建信号中的block,直到成功.</p>
</blockquote>
<h4 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h4><blockquote>
<p>节流:当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> RACSubject *signal = [RACSubject subject]; </span><br><span class="line"> _signal = signal; </span><br><span class="line">    // 节流，在一定时间（1秒）内，不接收任何信号内容，过了这个时间（1秒）获取最后发送的信号内容发出。</span><br><span class="line"> [[signal throttle:1] subscribeNext:^(id x) &#123;             </span><br><span class="line">        NSLog(@&quot;%@&quot;,x); </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>References:</p>
<p><a href=":https://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1">MVVM+RAC英文教程</a></p>
<p><a href>http:\/\/www.jianshu.com\/p\/87ef6720a096</a></p>
<p><a href>http:\/\/www.cocoachina.com\/ios\/20150123\/10994.html</a></p>
</blockquote>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2015/11/23/UIScrollView-的-delaysContentTouches/">UIScrollView 的 delaysContentTouches</a><a class="next" href="/2015/07/25/runtime黑魔法-Method-Swizzling-md/">runtime黑魔法-Method Swizzling.md</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://yincongxiao.top/2015/11/15/reactivecocoa深入学习/';
    this.page.identifier = '2015/11/15/reactivecocoa深入学习/';
    this.page.title = 'reactivecocoa深入学习';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//[object Object].disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//[object Object].disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://[object Object].disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yincongxiao.top"></form></div><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="http://yincongxiao.top"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOSTips/">iOSTips</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS源码分析/">iOS源码分析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/CoreAnimation/" style="font-size: 15px;">CoreAnimation</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/16/Xcode运行python脚本/">Xcode运行python脚本</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/28/Swift4-0/">Swift4.0</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/18/Https简单复习/">Https简单复习.md</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/23/Toll-Free-Bridging/">Toll-Free Bridging</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/20/YYMemeryCache-study/">YYMemeryCache-study</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/15/YYDiskCache-study/">YYDiskCache study</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/02/GCD-dispatch-source/">GCD-dispatch_source</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/10/dispatch-group-t-使用详解/">dispatch_group_t 使用详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/02/dispatch-barrier使用详解/">dispatch_barrier使用详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/06/CoreAnimation-CALayer-四/">CoreAnimation-CALayer(四)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//[object Object].disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">aSnail.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>