<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>aSnail</title>
  
  <subtitle>年轻就是折腾</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yincongxiao.top/"/>
  <updated>2019-07-08T03:39:27.723Z</updated>
  <id>http://yincongxiao.top/</id>
  
  <author>
    <name>aSnail</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS 和 MacOSX 中的内存管理</title>
    <link href="http://yincongxiao.top/2019/07/08/iOS-%E5%92%8C-MacOSX-%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yincongxiao.top/2019/07/08/iOS-和-MacOSX-中的内存管理/</id>
    <published>2019-07-08T03:36:15.000Z</published>
    <updated>2019-07-08T03:39:27.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-和-MacOSX-中的内存管理"><a href="#iOS-和-MacOSX-中的内存管理" class="headerlink" title="iOS 和 MacOSX 中的内存管理"></a>iOS 和 MacOSX 中的内存管理</h1><p>为什么想到聊内存管理,是因为最近做了一个APM相关的SDK,其中需要采集app内存使用情况,其中有很长一段时间的探索过程,这篇就是过程中回顾到的一些知识,在此记录一下.<br>谈到iOS中的内存管理,大家可能首先想到的是ARC,确实编译器帮我们完成了大部分开发中需要注意的内存问题,但是理解内存管理对我们开发很有帮助,不仅可以帮助我们提高app内存表现,还能在一定程度上释放CPU的压力.还可以为开发中遇到的各种各样的内存问题诸如<code>爆内存</code>,<code>内存泄露</code>,<code>坏内存访问</code>等等疑难杂症提供解决思路.</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p><strong>什么是虚拟内存</strong><br>因为同时运行在操作系统上的进程是很多的,环境非常复杂,如果所有软件都直接向物理内存中申请内存,那很容易导致其他应用出现问题,甚至可能将操作系统搞挂,还有一个问题是物理内存空间通常是比较有限的,写程序如果在一个有限的环境下那会导致很多功能无法实现,还有很多很多其他的问题.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">All problems in computer science can be solved by another level of indirection – David Wheeler </span><br><span class="line">计算机科学中的任何问题，都可以通过加上一层逻辑层来解决。– David Wheeler</span><br></pre></td></tr></table></figure><p>为了解决这些问题计算机科学引入了虚拟内存,虚拟内存为所有应用程序统一管理应用内存的分配和释放</p><p>在iOS和OSX系统内部都有全套完整的虚拟内存系统,虚拟内存将进程完美的分开,对每个进程来说好像是独立拥有手机的全部内存空间一样,对于32位系统来说你拥有<code>2^32</code>也就是4GB的虚拟内存控件可以操作,对于64位系统来说有18eb.<br><img src="https://s.momocdn.com/w/u/others/2019/07/03/1562147360475-vm_address.jpg" alt></p><h4 id="在iOS中内存是如何创建并管理的"><a href="#在iOS中内存是如何创建并管理的" class="headerlink" title="在iOS中内存是如何创建并管理的?"></a>在iOS中内存是如何创建并管理的?</h4><p><img src="https://s.momocdn.com/w/u/others/2019/07/03/1562146976883-VM_graph.jpg" alt></p><p><strong>虚拟内存中的细节</strong></p><p><strong>分片(page)&amp;pagging</strong><br>在操作系统内存管理中,片(page)是内存管理的最小单元,无论是物理内存还是虚拟内存都按照一个个连续的片分割开来,在iOS4之前一个page的大小为4kb,iOS4之后的系统都是16kb/page,我们创建一个对象,系统会为我们分配一个page或者若干个page.<br>当我们在代码中使用malloc申请一段内存时,其实操作系统只是在虚拟内存中帮我们申请了指定大小的内存,并没有去物理内存中申请,当我们向申请的这段内存写数据时,<br>,我们试图去向第一片内存中写数据时,</p><div><img align="center" height="400" weight="100" src="https://s.momocdn.com/w/u/others/2019/07/02/1562067642575-Xnip2019-07-02_19-39-52.jpg"></div><h4 id="clean-amp-dirty-memory"><a href="#clean-amp-dirty-memory" class="headerlink" title="clean &amp; dirty memory"></a>clean &amp; dirty memory</h4><p>我们将内存page的状态分为两种:<br>clean memory: 基于 readonly 文件而被加载到内存中的Page称为 clean memory，比如：系统 framework、可执行文件、通过 mmap 方式读取的文件等。这种 Page 由于是加载自不可变的文件，因此可以在物理内存紧张时被 iOS 自动 unload 出去，并且在需要的时候再重新从原来的文件加载到内存中。<br>dirty memory:凡是非 clean 的 Page 都是 dirty 的，它们的共同特点是 Page 在disk中没有对应的文件，比如通过 alloc 在堆上创建的内存空间，已经解压的图片，database caches 等.dirty memory 不能被操作系统交换出去，只有在进程被杀死的时候才能被回收，因此在系统发生内存告警时，如果进程创建了大量的 dirty memory，那么将很有可能被 kill 掉。</p><p>怎样判断我们申请的内存时clean的还是dirty的呢?来看下面的例子顺便详细说明虚拟内存的工作原理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  <span class="keyword">int</span> *intArr = <span class="built_in">malloc</span>(<span class="number">20000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="number">2.</span>  intArr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="number">3.</span>  intArr[<span class="number">1999</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>在上面代码中,当我们使用malloc函数申请一段内存时,虚拟内存是怎么工作的呢?<br>系统在执行到第1行代码时,虽然我们向系统申请了<code>20000 * sizeof(int)</code>长度的内存,系统只是在虚拟内存中帮我们分配了6页内存页,这些内存页并没有与物理内存中的page建立映射,这样的页为<code>clean memory</code>,在执行到第2行代码时操作系统发现这段在虚拟内存中的页并没有映射到物理内存中,那么此时就会触发一个<a href="https://zh.wikipedia.org/wiki/%E9%A1%B5%E7%BC%BA%E5%A4%B1" target="_blank" rel="noopener">页错误</a>,然后操作系统通过<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83" target="_blank" rel="noopener">MMU</a>单元计算出物理内存地址,然后操作系统会在物理内存中申请内存,返回给应用程序,此时也就将此片虚拟内存和物理内存建立了映射,这个过程称为<code>pagging</code>.在iOS中我们称这样的内存片为<code>dirty memory</code>.<br>当执行完第3行代码时,系统会将第6片内存页映射到物理内存,这片内存也变成dirty,而中间1998个内存片依然是clean的.</p><p>再来看下面的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *helloWordStr = [NSString stringWithUTF8String:&quot;hello word&quot;];</span><br><span class="line">NSString *helloWordStr2 = @&quot;hello word&quot;;</span><br></pre></td></tr></table></figure></p><p>对于helloWordStr,因为这个方法会把字符串常量拷贝到堆区,所以是dirty,而下面的helloWordStr2在DATA段,这部分的数据是readonly的,所以它是clean的.<br>还有类似<code>[UIImage imageNamed:@&quot;&quot;];</code>以及<code>core graph</code>中的方法创建出来的图片都是dirty memory.我们app中大部分的操作产生的都是dirty memory</p><h3 id="内存紧张时系统如何处理"><a href="#内存紧张时系统如何处理" class="headerlink" title="内存紧张时系统如何处理"></a>内存紧张时系统如何处理</h3><p>在macOS中有置换机制,使用磁盘来为RAM”扩容”,但是在iOS中没有这个机制.iOS只能尝试去将dirty memory清理一部分, iOS7之后还引入了memory compress技术,简单那来说就是在内存不足时系统可以把一部分dirty内存压缩,这样就能腾出一部分空间,系统也会给进程发送memorywarnning通知,如果app没有及时处理系统就会先把后台进程杀掉,所以如果我们app申请过大内存也影响其他app的体验,通过杀掉后台app系统已经腾出一部分空间出来,但是如果进程继续申请很多内存,系统只能把前台app也杀掉.</p><p>怎样防止app被kill掉呢,我们要注意减少dirty memory的使用.</p><p>我们通常所说的footprint memory就是dirty + complessed memory.</p><div><img height="400" weight="100" src="https://s.momocdn.com/w/u/others/2019/07/04/1562227277284-foot_print.jpg"></div><br>注意在清理缓存的过程中有一个陷阱:下面举例说明<br>有这样一个场景我使用一个<code>NSMutableDictionary *</code>对象缓存了一些数据,收到内存警告时我把我的缓存中的对象全部清除<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning &#123;</span><br><span class="line">    [self.cacheDict removeAllObjects];</span><br><span class="line">    [super didReceiveMemoryWarning];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>很遗憾的是这个看似比较负责的做法可能会适得其反,因为有memory compress 的存在,所以在内存紧张时我的cache中的数据可能已经被压缩了一部分例如下面图<br><br><div><img height="100" weight="400" src="https://s.momocdn.com/w/u/others/2019/07/04/1562227307649-compressed_dic.jpg"></div><p>但是当内存警告时我试图清理掉他们,然后访问这些数据,结果内核会将这个压缩的内存解压缩给我们用,导致dirty memory直线上升,很可能因为这样的操作导致app提前被kill.</p><div><img height="100" weight="400" src="https://s.momocdn.com/w/u/others/2019/07/04/1562227284619-compless_fail.jpg"></div><br>这不是我们想看到的.应该怎么做呢,如果我们使用了NSDictionary,NSArray等容器,等收到memory warining时一定要小心处理缓存,我们尽量去不再申请更多的内存,而不是去碰这些内存.系统提供了NSPurgeableDataw我们可以使用这个数据来封装我们的缓存数据<br>另一个比较好的方式直接使用NSCache容器,NSCache相较NSDictionary有很多优点<br>1. 它是线程安全的<br>2. 缓存到NSCache中的数据是Purgeable的,当发生内存紧张时系统可以释放他们腾出空间.<br>3. NSCache不会拷贝key.<br>4. 在清理策略上也是具有LRU策略,总之在典型的内存缓存场景下NSCache很多优势.<br><br>另外在app退后台时可以在不影响用户体验的情况下尽可能多的释放内存,这样可避免在后台时被杀死,<a href="https://github.com/Split82/iOSMemoryBudgetTest" target="_blank" rel="noopener">这个demo</a>可以测试你的机型极限情况下可以申请的内存最大数量,<a href="https://stackoverflow.com/questions/5887248/ios-app-maximum-memory-budget" target="_blank" rel="noopener">这个问题</a>列举了一些人做的实验可以作为一些参考.<br><br><strong>wired memory</strong><br>wired memory 又称为resident memory,是操作系统内核或者其他不能被pagging out的内存,用户空间是不能申请wired memory的,但是用户空间的行为可以影响wired memory,比如程序通过创建线程或者mach port等来隐式的增大 wired memory.比如一个正常的而线程大概占用5个字节的wired memory,一个被阻塞的线程大概占用21个字节的空间.<br>每一个线程,进程,port,后者二进制库都会影响wired memory的大小,系统内核需要使用wired memory来做一下几个事情: vm_object, 虚拟内存缓存,驱动,io缓存.系统需要使用维护虚拟内存和物理内存的映射关系,所以当你申请一段内存时没有进行定其他操作wired memory也会增加.<br>在 mac中只打开finder一个应用,如果你的电脑内存有64M内存,就会有大约14M<code>wired memory</code>,如果你是128M内存的电脑,大约有17M<code>wired memroy</code>.<br>wired memory在不使用时并不会马上变成空间内存,而是当空闲内存少于阈值时触发系统pagging out时才会被回收.<br><br>### OSX中的内存管理<br>#### pagging in &amp; pagging out<br><br>当内存可用空间不足时,操作系统会采取一些措施以腾出可用空间,这个具体操作根据系统不同而不同,在OSX中会将内存中的page交换到磁盘中的<code>backing store</code>中,<code>backing store</code>是一片用来存放置换片的磁盘空间.这个置换过程称之为<code>pagging out</code>.当程序访问这些已经置换到磁盘的内存片时,操作系统就会将这些page从<code>backing store</code>置换到内存中,这个过程称之为<code>pagging in</code>.系统在进行page in 或者page out时性能通常不好,所以每个OSX中的app开发者都应该尽量减少太多内存的申请,下面会具体介绍pagging out 和pagging in的过程.<br><br>操作系统将物理内存中的page根据状态记录在三个队列中:<br>active list: 这部分page已经映射到虚拟内存中,并且最近访问过<br>inactive list: 这部分page已经映射到虚拟内存中,但是最近没有访问过<br>free list: 这部分page 有映射到虚拟内存,可以随时被进程使用.<br><br><strong>pagging out</strong><br>当系统free list中的page count低于设定阈值时(这个阈值根据物理内存的大小决定),操作系统会调整三个列表,以腾出内存空间来<br>在active list中的内存片如果长时间没有访问,那么内核就会将这部分内存片放到inactive list 中.<br>在inactive list中的内存片如果长时间没有访问,那么内核尝试根据这个page的vm_object查看该片段中的内存是不是被置换到磁盘中过,如果没有被置换到磁盘中过,内核生成一个pager对象,pager对象会将这个内存片置换到磁盘的<code>backing store</code>中,如果pager置换成功了就将这个腾出来的内存片放到free list中.<br>如果一个在inactive list中的内存段最近没有访问过,并且这部分内存不是wired memory,内核将这个内存片与虚拟内存的关联取消,并且抹掉放到free list中.一旦free list达到了阈值那么这个过程就会停止.<br>这点在iOS系统中是不同的,(iOS中这部分inactive list中的page并不会置换到磁盘中,而是交给使用这部分内存的应用清理,触发memory warnning).应用程序手动清理内存以后,内核就会把这部分内存片放到free list中.<br><br><strong>pagging in</strong><br>当程序试图访问虚拟内存中的内存片时,如果该内存片没有和物理内存中建立映射,那么就会发生页错误,页错误分为软错误和硬错误两种<br>软错误: 程序试图访问的内存地址在物理内存中有,但是并没有和程序的虚拟内存系统建立映射关系<br>硬错误: 程序试图访问的内存地址在物理内存中没有,已经被交换或者被映射在mmap文件中<br>当遇到页错误时内核首先会定位这个内存片所在的region中,找到相关的vm object,然后查找vm object中的resident list,如果resident list中有想访问的内存片,那么就将这个页错误归为软错误,否则归为硬错误.<br>对于软错误,系统将这个物理内存片和虚拟内存地址关联起来,并且给这个内存片放到active list中.<br>对于硬错误,内核在磁盘的backing store中找到这个内存片,将这个内存片写到物理内存中,并且将这个内存片放到active list中.<br><br>讲了这么多其实在iOS中是没有<code>pagging out</code>机制的,但是在某些特性情况下一些只读数据是可以发生<code>pagging in</code>的.<br><br><strong>mmap</strong><br>通常我们访问磁盘中的一个文件需要将文件首先读到内存中,操作完毕再将内存中的文件写入磁盘,其中的读取是有拷贝操作.系统提供了mmap()函数可以允许进程直接对磁盘中的文件建立映射关系,进程可以像读写内存一样对普通文件的操作,该文件的销毁由系统接管,比read少了一次拷贝操作,因此性能更好,在读取磁盘大文件中的一部分这种场景下有突出的优势,基于这个优势可以写一个高效率的写文件工具.<br><div><img height="400" weight="100" src="https://s.momocdn.com/w/u/others/2019/07/03/1562127792223-mmap.jpg"></div><p>mmap的另一个重要用法是实现进程间文件的共享,感兴趣可以自行google</p><p>参考文章:</p><ul><li><a href="https://developer.apple.com/videos/play/wwdc2018/416/?time=134" target="_blank" rel="noopener">WWDC_2018_416_trim your footprint</a></li><li><a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html#//apple_ref/doc/uid/20001880-99100-TPXREF113" target="_blank" rel="noopener">AboutMemory</a></li><li><a href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/vm/vm.html#//apple_ref/doc/uid/TP30000905-CH210-CHDEDGCA" target="_blank" rel="noopener">Kernel Programming Guide</a></li><li><a href="https://forums.developer.apple.com/thread/105088" target="_blank" rel="noopener">talking about memory access</a></li><li>&lt;&lt;深入理解计算机系统&gt;&gt;</li></ul>]]></content>
    
    <summary type="html">
    
      理解内存管理对我们开发很有帮助,不仅可以帮助我们提高app内存表现,还能在一定程度上释放CPU的压力.还可以为开发中遇到的各种各样的内存问题诸如`爆内存`,`内存泄露`,`坏内存访问`等等疑难杂症提供解决思路.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于AMP</title>
    <link href="http://yincongxiao.top/2019/05/23/%E5%85%B3%E4%BA%8EAMP/"/>
    <id>http://yincongxiao.top/2019/05/23/关于AMP/</id>
    <published>2019-05-23T03:39:54.000Z</published>
    <updated>2019-05-23T04:20:10.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AMP"><a href="#AMP" class="headerlink" title="AMP"></a>AMP</h2><p>今年年后部门进行了架构调整,我也正式从业务部门调到质量部,这对我来说是一次比较大的变动.</p><p>  先总结一下之前的工作吧,虽然之前也是技术部,但是一直做一款商业部主导的产品,做版本开发已经很熟练,从版本评审,排期到开发上线,整个过程其实开发不算是最主要的工作,最主要的还是跟各端的沟通上.这个产品做了一年多也取得了比较大的成果,无论是从用户数量上还是商业部门业绩kpi上都是去年公司比较亮眼的项目,总结一下这段时间的工作就是比较琐碎,要说成长的话就是一个是熟悉了大型直播间项目的架构组织,以及音视频通讯类产品的解决方案,另一个是提高了对版本开发整体的把控能力,这个能力我觉得是个更重要的.</p><p>  去年的时候部门客户端老大找我谈话,想拉我去参与一个<code>Lua</code>跨平台框架的开发,我之前也使用过两款跨平台技术(rn,weex)进行开发,这两个框架虽说都不完善,其中很多坑,但是还是可以大幅度提高客户端开发效率的,尤其是在热发布上这是传统客户端开发不能比的,整体来说我对跨平台开发还是很有好感的,相信以后这也是个趋势.但是当时项目是在太紧了,到后来也就不了了之了.</p><p>  今年年后老大又来找到我说有个新组成立问我是不是感兴趣,了解到是关于性能采集的,apm对客户端开发都是比较重要的,这次果断答应了<br>  质量部的工作主要是为各个app提供质量方面的支持,包括crash采集,卡顿,页面打开速度,内存峰值,内存泄露,大内存访问等,还有面还会有反馈系统.对于app质量之前也有过比较浅的研究,仅限于版本做完之后的性能自测,停留在debug阶段.但是这次要做一个线上产品出来,我自己也是解除了很多没有接触过的知识.<br>  所以这次单独会开辟一个category来存放app只想相关的文章,希望能够全面的记录下来.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AMP&quot;&gt;&lt;a href=&quot;#AMP&quot; class=&quot;headerlink&quot; title=&quot;AMP&quot;&gt;&lt;/a&gt;AMP&lt;/h2&gt;&lt;p&gt;今年年后部门进行了架构调整,我也正式从业务部门调到质量部,这对我来说是一次比较大的变动.&lt;/p&gt;
&lt;p&gt;  先总结一下之前的工作吧,
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Xcode运行python脚本</title>
    <link href="http://yincongxiao.top/2019/05/16/Xcode%E8%BF%90%E8%A1%8Cpython%E8%84%9A%E6%9C%AC/"/>
    <id>http://yincongxiao.top/2019/05/16/Xcode运行python脚本/</id>
    <published>2019-05-16T13:03:30.000Z</published>
    <updated>2019-05-17T04:48:19.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Xcode运行python脚本"><a href="#Xcode运行python脚本" class="headerlink" title="Xcode运行python脚本"></a>Xcode运行python脚本</h2><p>Xcode可以允许我们使用一些脚本进行编译前的自动化工作,通常使用shell脚本,但是很多人可能会和我一样对python脚本更有兴趣,那么怎样使用Xcode运行python脚本呢?</p><p>我们知道shell脚本可以直接访问xcode的环境变量,但是python脚本却不行.</p><p>打开TARGETS-&gt;Build Phases-&gt;Run Script<br>将下面shell脚本复制进去,或者提取到外部shell脚本中执行.<br>注意这里还是实用的shell <code>/bin/sh</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function callPythonScript() &#123;</span><br><span class="line">    # 将GCC_PREPROCESSOR_DEFINITIONS参数传递到puthon的&lt;sys.argv&gt;里.</span><br><span class="line">    python $1 $&#123;GCC_PREPROCESSOR_DEFINITIONS&#125;;</span><br><span class="line"></span><br><span class="line">    # 错误判断.</span><br><span class="line">    return_code=$?</span><br><span class="line">    if [ $return_code -ne 0 ]; then</span><br><span class="line">    exit 1;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 使用上面的callPythonScript()函数执行python脚本.</span><br><span class="line">cd $SRCROOT </span><br><span class="line">cd ..</span><br><span class="line">callPythonScript ./ptScript.py</span><br><span class="line"></span><br><span class="line">exit 0;</span><br></pre></td></tr></table></figure><p>ptScript.py</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"><span class="keyword">print</span> os.environ[<span class="string">'PRODUCT_NAME'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制台输出</span></span><br><span class="line"><span class="comment"># &gt;&gt; DemoProject</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Xcode可以允许我们使用一些脚本进行编译前的自动化工作,通常使用shell脚本,但是很多人可能会和我一样对python脚本更有兴趣,那么怎样使用Xcode运行python脚本呢?
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Swift4.0</title>
    <link href="http://yincongxiao.top/2018/04/28/Swift4-0/"/>
    <id>http://yincongxiao.top/2018/04/28/Swift4-0/</id>
    <published>2018-04-28T02:54:40.000Z</published>
    <updated>2019-05-17T04:58:09.728Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../imgs/add_run_script.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;../imgs/add_run_script.jpg&quot; alt&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Https简单复习.md</title>
    <link href="http://yincongxiao.top/2017/03/18/Https%E7%AE%80%E5%8D%95%E5%A4%8D%E4%B9%A0/"/>
    <id>http://yincongxiao.top/2017/03/18/Https简单复习/</id>
    <published>2017-03-18T09:02:43.000Z</published>
    <updated>2019-05-16T11:52:21.685Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTPS简单复习"><a href="#HTTPS简单复习" class="headerlink" title="HTTPS简单复习"></a>HTTPS简单复习</h3><p><img src="http://o7vzr7y09.bkt.clouddn.com/440px-Internet2.jpg" alt><br>现在全站HTTPS的时代已经到来了,最近把https的概念复习了一下<br>https在http请求的基础上多加了一个证书认证的流程。认证通过之后，数据传输都是加密进行的。<br>https的认证过程分为单项认证和双项认证</p><h4 id="单项认证过程"><a href="#单项认证过程" class="headerlink" title="单项认证过程"></a>单项认证过程</h4><p><img src="http://upload-images.jianshu.io/upload_images/2702646-c6f158b5d4ad4602.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ol><li>客户端发起HTTPS请求<br>这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口(http的默认TCP端口是80)。这里客户端传递的内容中包括SSL协议版本,支持的加密算法和一个随机数1.</li><li>服务端的配置<br>采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。<br>　　这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</li><li>传送证书<br>　　这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等,同时告诉客户端将使用的加密算法,还有随机数2。</li><li><p>客户端解析证书<br>　这部分工作是有客户端的TLS/SSL来完成,大概有下面几个步骤:</p><ul><li>证书是否过期</li><li>发型服务器证书的CA是否可靠</li><li>返回的公钥是否能正确解开返回证书中的数字签名</li><li>服务器证书上的域名是否和服务器的实际域名相匹配  </li></ul><p>如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值3。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p></li><li>传送加密信息<br> 将随机数传递给服务器</li><li>服务段解密信息<br>　　服务端用私钥解密后，得到了客户端传过来的随机值，这样服务器和客户端都有了三套随机数,然后服务端和客户端各使用之前约定的加密算法生成对称秘钥(session key),然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</li><li>传输加密后的信息<br>　　这部分信息是服务端用私钥加密后的信息，可以在客户端被还原。</li><li>客户端解密信息<br>　　客户端用之前生成的对称秘钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。</li></ol><p>这就是整个https验证的流程了,这里省略了中间客户端传递自己支持的加密算法的步骤。简单总结一下：</p><ul><li>首先服务端要有一对秘钥<br>用户发起请求，服务器响应后返回一个证书(公钥)，证书中包含一些基本信息(证书的颁发机构,证书过期时间等)和公钥。</li><li>用户拿到证书后，去验证这个证书是否合法，不合法，则请求终止。<br>合法则生成一个随机数，作为对称加密的密钥，用服务器返回的公钥对这个随机数加密。然后返回给服务器。</li><li>服务器拿到加密后的随机数，利用私钥解密，然后再用解密后的随机数（对称密钥），把需要返回的数据加密，加密完成后数据传输给用户。</li><li>最后用户拿到加密的数据，用一开始的那个随机数（对称密钥），进行数据解密。整个过程完成。</li></ul><h5 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h5><p>双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下：<br><img src="http://img.blog.csdn.net/20160310160519781" alt></p><h5 id="对称加密-amp-非对称加密"><a href="#对称加密-amp-非对称加密" class="headerlink" title="对称加密&amp;非对称加密"></a>对称加密&amp;非对称加密</h5><p>上面提到了对称加密和非对称加密,他们有什么区别呢</p><ul><li>对称加密: 速度高，可加密内容较大，用来加密<strong>会话过程</strong>中的消息</li><li>非对称加密: 加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥</li></ul><p>上面SSL单项认证过程中客户端使用服务端的公钥加密随机数的过程就是非对称加密,又称为公钥加密,服务端通过随机数将内容加密的过程就是对称加密.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HTTPS简单复习&quot;&gt;&lt;a href=&quot;#HTTPS简单复习&quot; class=&quot;headerlink&quot; title=&quot;HTTPS简单复习&quot;&gt;&lt;/a&gt;HTTPS简单复习&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://o7vzr7y09.bkt.clouddn.com
      
    
    </summary>
    
      <category term="iOSTips" scheme="http://yincongxiao.top/categories/iOSTips/"/>
    
    
  </entry>
  
  <entry>
    <title>Toll-Free Bridging</title>
    <link href="http://yincongxiao.top/2017/02/23/Toll-Free-Bridging/"/>
    <id>http://yincongxiao.top/2017/02/23/Toll-Free-Bridging/</id>
    <published>2017-02-23T13:15:07.000Z</published>
    <updated>2019-05-16T11:52:21.686Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Toll-Free-Bridging"><a href="#Toll-Free-Bridging" class="headerlink" title="Toll-Free Bridging"></a>Toll-Free Bridging</h3><p>翻译自<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html#//apple_ref/doc/uid/TP40010810-CH2" target="_blank" rel="noopener">Apple</a>.</p><h4 id="关于Toll-Free-Bridging"><a href="#关于Toll-Free-Bridging" class="headerlink" title="关于Toll-Free Bridging"></a>关于Toll-Free Bridging</h4><p>我们日常开发中一般使用Fundation的类,其中有一些是跟Core Fundation 框架中的类是可以进行内部转换的,这个特性就被称之为<code>Toll-Free Bridging</code>,意味着你可以使用同一种数据结构作为Core Fundation 中函数的参数,或者作为Fundation中方法的参数.例如<a href="https://developer.apple.com/reference/foundation/nslocale" target="_blank" rel="noopener">NSLocal</a>与<a href="https://developer.apple.com/reference/corefoundation/cflocale" target="_blank" rel="noopener">CFLocal</a>就是Toll-Free Bridging 的.所以,如果你在使用一个需要传递(NSLocal *)类型的参数的OC方法的时候,你可以传递一个CFLocalRef类型的值进去.反过来也一样.你可以只创建以一种类型的对象s来避免编译器的警告.<br>例如以下的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSLocale *gbNSLocale = [[NSLocale alloc] initWithLocaleIdentifier:@<span class="string">"en_GB"</span>];</span><br><span class="line">CFLocaleRef gbCFLocale = (CFLocaleRef) gbNSLocale;</span><br><span class="line">CFStringRef cfIdentifier = CFLocaleGetIdentifier (gbCFLocale);</span><br><span class="line">NSLog(@<span class="string">"cfIdentifier: %@"</span>, (NSString *)cfIdentifier);</span><br><span class="line"><span class="comment">// logs: "cfIdentifier: en_GB"</span></span><br><span class="line">CFRelease((CFLocaleRef) gbNSLocale);</span><br><span class="line">CFLocaleRef myCFLocale = CFLocaleCopyCurrent();</span><br><span class="line">NSLocale * myNSLocale = (NSLocale *) myCFLocale;</span><br><span class="line">[myNSLocale autorelease];</span><br><span class="line">NSString *nsIdentifier = [myNSLocale localeIdentifier];</span><br><span class="line">CFShow((CFStringRef) [@<span class="string">"nsIdentifier: "</span> stringByAppendingString:nsIdentifier]);</span><br><span class="line"><span class="comment">// logs identifier for current locale</span></span><br></pre></td></tr></table></figure><p>这里需要注意的是,我们用到的内存管理语句同样是Toll-Free Bridging的,所以你可以使用CFRelease来释放Cocoa对象,也可以吧release和autorelease用在Core Fundation的对象上<br>但是如果使用garbage collectin 进行内存管理的话,Core Fundation 和Cocoa对象会有很大的差异.<br>下面有一张对照表,列出了在Core Fundation和在Fundation中是Toll-Free Bridging转换的</p><table><thead><tr><th>Core Fundation Type</th><th>Fundation class</th><th>Availability</th></tr></thead><tbody><tr><td>CFArrayRef</td><td>NSArray</td><td>OS X 10.0</td></tr><tr><td>CFAttributedStringRef</td><td>NSAttributedString</td><td>OS X 10.4</td></tr><tr><td>CFBooleanRef</td><td>NSNumber</td><td>OS X 10.0</td></tr><tr><td>CFCalendarRef</td><td>NSCalendar</td><td>OS X 10.4</td></tr><tr><td>CFCharacterSetRef</td><td>NSCharacterSet</td><td>OS X 10.0</td></tr><tr><td>CFDataRef</td><td>NSData</td><td>OS X 10.0</td></tr><tr><td>CFDateRef</td><td>NSDate</td><td>OS X 10.0</td></tr><tr><td>CFDictionaryRef</td><td>NSDictionary</td><td>OS X 10.0</td></tr><tr><td>CFErrorRef</td><td>NSError</td><td>OS X 10.5</td></tr><tr><td>CFLocaleRef</td><td>NSLocale</td><td>OS X 10.4</td></tr><tr><td>CFMutableArrayRef</td><td>NSMutableArray</td><td>OS X 10.0</td></tr><tr><td>CFMutableAttributedStringRef</td><td>NSMutableAttributedString</td><td>OS X 10.4</td></tr><tr><td>CFMutableCharacterSetRef</td><td>NSMutableCharacterSet</td><td>OS X 10.0</td></tr><tr><td>CFMutableDataRef</td><td>NSMutableData</td><td>OS X 10.0</td></tr><tr><td>CFMutableDictionaryRef</td><td>NSMutableDictionary</td><td>OS X 10.0</td></tr><tr><td>CFMutableSetRef</td><td>NSMutableSet</td><td>OS X 10.0</td></tr><tr><td>CFMutableStringRef</td><td>NSMutableString</td><td>OS X 10.0</td></tr><tr><td>CFNullRef</td><td>NSNull</td><td>OS X 10.2</td></tr><tr><td>CFNumberRef</td><td>NSNumber</td><td>OS X 10.0</td></tr><tr><td>CFReadStreamRef</td><td>NSInputStream</td><td>OS X 10.0</td></tr><tr><td>CFRunLoopTimerRef</td><td>NSTimer</td><td>OS X 10.0</td></tr><tr><td>CFSetRef</td><td>NSSet</td><td>OS X 10.0</td></tr><tr><td>CFStringRef</td><td>NSString</td><td>OS X 10.0</td></tr><tr><td>CFTimeZoneRef</td><td>NSTimeZone</td><td>OS X 10.0</td></tr><tr><td>CFURLRef</td><td>NSURL</td><td>OS X 10.0</td></tr><tr><td>CFWriteStreamRef</td><td>NSOutputStream</td><td>OS X 10.0</td></tr></tbody></table><ul><li>注意:并不是所有的类都是Toll-Free Bridging 的,例如NSRunLoop和CFRunLoopRef就不是,NSDateFormate和CFDateFormateRef也不是.</li></ul><p>如果foundation某一个类是Toll-Free Bridging 的,那么在该类的头文件中按住option点击类名字,就会看到对应的core foundation 的类<br><img src="http://o7vzr7y09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-19%20%E4%B8%8B%E5%8D%881.27.46.png" alt></p><h4 id="bridge-bridge-transfer-bridge-retained关键字"><a href="#bridge-bridge-transfer-bridge-retained关键字" class="headerlink" title="bridge, bridge_transfer,__bridge_retained关键字"></a><strong>bridge, </strong>bridge_transfer,__bridge_retained关键字</h4><p>我们知道，ARC环境下，编译器不会自动管理CF对象的内存，我们需要手动管理。这就是我们在创建一个CF对象以后需要我们使用CFRelease将其手动释放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSLocale *gbNSLocale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_GB&quot;];</span><br><span class="line">CFLocaleRef gbCFLocale = (CFLocaleRef) gbNSLocale;</span><br><span class="line">CFStringRef cfIdentifier = CFLocaleGetIdentifier (gbCFLocale);</span><br><span class="line">NSLog(@&quot;cfIdentifier: %@&quot;, (NSString *)cfIdentifier);</span><br><span class="line">// logs: &quot;cfIdentifier: en_GB&quot;</span><br><span class="line">CFRelease((CFLocaleRef) gbNSLocale);</span><br></pre></td></tr></table></figure><p>例如上面的例子,我们将<code>NSLocale *</code>类型的对象转换成<code>CFLocaleRef</code>的对象以后默认情况下<code>gbNSLocale</code>的内存管理任务也就从ARC交给了我们,我们需要在后面手动释放<code>CFRelease((CFLocaleRef) gbNSLocale);</code></p><h5 id="bridge"><a href="#bridge" class="headerlink" title="__bridge"></a>__bridge</h5><p>CF和OC对象转化时只涉及对象类型不涉及对象所有权的转化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSArray *anNSArray = @[@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">3</span>];</span><br><span class="line">CFArrayRef anCFArray = (__bridge CFArrayRef)anNSArray;</span><br><span class="line">NSLog(@<span class="string">"size of array is %li"</span>,CFArrayGetCount(anCFArray));</span><br><span class="line">输出台:</span><br><span class="line"><span class="comment">//size of array is = 3</span></span><br></pre></td></tr></table></figure><p>这里用到了<code>__bridge</code>关键字,它的意思是,虽然将NSArray类型的对象转成了CFArrayRef类型的结构,但是ARC仍然对该对象具有内存管理权限,所以我们不需要负责anCFArray的释放,也就不用添加<code>CFRelease(anCFArray);</code></p><h5 id="bridge-transfer"><a href="#bridge-transfer" class="headerlink" title="__bridge_transfer"></a>__bridge_transfer</h5><p>常用在CF对象转化成OC对象时，将CF对象的所有权交给OC对象，此时ARC就能自动管理该内存,作用同CFBridgingRelease()</p><h5 id="bridge-retained"><a href="#bridge-retained" class="headerlink" title="__bridge_retained"></a>__bridge_retained</h5><p>__bridge_retained（也可以使用CFBridgingRetain）将Objective-C的对象转换为Core Foundation的对象，同时将对象（内存）的管理权交给我们，后续需要使用CFRelease或者相关方法来释放对象；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSArray *anNSArray = @[@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">3</span>];</span><br><span class="line">CFArrayRef anCFArray = (__bridge_retained CFArrayRef)anNSArray;</span><br><span class="line">NSLog(@<span class="string">"size of array is %li"</span>,CFArrayGetCount(anCFArray));</span><br><span class="line">CFRelease(anCFArray);</span><br><span class="line">输出台:</span><br><span class="line"><span class="comment">//size of array is = 3</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Toll-Free-Bridging&quot;&gt;&lt;a href=&quot;#Toll-Free-Bridging&quot; class=&quot;headerlink&quot; title=&quot;Toll-Free Bridging&quot;&gt;&lt;/a&gt;Toll-Free Bridging&lt;/h3&gt;&lt;p&gt;翻译自&lt;a 
      
    
    </summary>
    
      <category term="iOSTips" scheme="http://yincongxiao.top/categories/iOSTips/"/>
    
    
  </entry>
  
  <entry>
    <title>YYMemeryCache-study</title>
    <link href="http://yincongxiao.top/2016/11/20/YYMemeryCache-study/"/>
    <id>http://yincongxiao.top/2016/11/20/YYMemeryCache-study/</id>
    <published>2016-11-20T03:17:25.000Z</published>
    <updated>2019-05-16T11:52:21.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="YYCache-tips"><a href="#YYCache-tips" class="headerlink" title="YYCache  tips"></a>YYCache  tips</h2><blockquote><p>之前YYKit刚开源的时候就粗略读过源码,当时真的是震惊,最近工作不忙,想细细读一遍,每次读作者的源码,膝盖都没有直起来过 - -~.  </p></blockquote><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><p>简单说一下YYCache的几个比较好的特性吧</p><ul><li>LRU: 缓存支持 LRU (least-recently-used) 淘汰算法。</li><li>缓存控制: 支持多种缓存控制方法：总数量、总大小、存活时间、空闲空间。</li><li>兼容性: API 基本和 NSCache 保持一致, 所有方法都是线程安全的。</li><li>内存缓存对象释放控制: 对象的释放(release) 可以配置为同步或异步进行，可以配置在主线程或后台线程进行。</li><li>自动清空: 当收到内存警告或 App 进入后台时，缓存可以配置为自动清空。</li><li>磁盘缓存可定制性: 磁盘缓存支持自定义的归档解档方法，以支持那些没有实现 NSCoding 协议的对象。</li><li>存储类型控制: 磁盘缓存支持对每个对象的存储类型 (SQLite/文件) 进行自动或手动控制，以获得更高的存取性能</li></ul></li><li><p>去<a href="https://github.com/ibireme/YYCache" target="_blank" rel="noopener">github</a>中看详细的介绍和使用方法,本文主要写自己在学习过程中的收货总结</p></li></ul><h2 id="YYMemoryCache"><a href="#YYMemoryCache" class="headerlink" title="YYMemoryCache"></a>YYMemoryCache</h2><ul><li>YYMemoryCache类的大体结构</li></ul><p><img src="/assets/屏幕快照 2017-03-09 下午5.14.40.png" alt></p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul><li><p>iOS中为了防止多线程对资源的抢夺,所有开发时使用锁来保证线程的安全,在<a href="http://blog.ibireme.com/author/ibireme/" target="_blank" rel="noopener">这篇文章</a>中作者详细介绍了iOS中几种锁的性能对比以及安全性的讨论</p><p><img src="http://blog.ibireme.com/wp-content/uploads/2016/01/lock_benchmark.png" alt="iOS中的锁"><br>在YYCache中采用的是pthread_mutex.</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个`pthread_mutex`锁</span></span><br><span class="line">pthread_mutex_init(&amp;_lock, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//在锁中操作对象</span></span><br><span class="line">pthread_mutex_lock(&amp;_lock);</span><br><span class="line"><span class="comment">// do something safely...</span></span><br><span class="line">pthread_mutex_unlock(&amp;_lock)</span><br></pre></td></tr></table></figure><h3 id="LRU淘汰算法"><a href="#LRU淘汰算法" class="headerlink" title="LRU淘汰算法"></a>LRU淘汰算法</h3><ul><li><strong>当LRU</strong>的实现:<em>It uses LRU (least-recently-used) to remove objects; NSCache’s eviction method</em>,在YYMemeryCache中使用了lru规则来进行缓存的淘汰,当发生内存警告或者缓存值达到上限,会优先淘汰哪些时间戳靠前的对象,最近使用的不被淘汰.YYMemoryCache中两个重要的内部对象<code>_YYLinkedMap</code>,<code>_YYLinkedMapNode</code></li></ul><h5 id="YYLinkedMapNode"><a href="#YYLinkedMapNode" class="headerlink" title="YYLinkedMapNode"></a>YYLinkedMapNode</h5><ul><li>_YYLinkedMapNode 是缓存系统中的最小单元,是对被存储对象的一层包装,直接被<code>_YYLinkedMap</code>所持有,先来看看这个类的声明</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYLinkedMapNode</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYLinkedMapNode *_prev; <span class="comment">// retained by dic</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYLinkedMapNode *_next; <span class="comment">// retained by dic</span></span><br><span class="line">    <span class="keyword">id</span> _key; <span class="comment">//锁存对象的key</span></span><br><span class="line">    <span class="keyword">id</span> _value; <span class="comment">//具体存储的对象</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _cost; <span class="comment">// 所存对象占用空间</span></span><br><span class="line">    <span class="built_in">NSTimeInterval</span> _time; <span class="comment">// 最近一次使用该对象的时间戳</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是这个对象中拥有了一个被存储对象全部的信息:key,元对象,以及在linkMap中的location,location的实现是通过持有前一个对象的指针以及后一个对象的指针来实现的</p><h5 id="YYLinkedMap"><a href="#YYLinkedMap" class="headerlink" title="YYLinkedMap"></a>YYLinkedMap</h5><ul><li>_YYLinkedMap是实现lru的关键,它是(_YYLinkedMapNode *)的集合,通过记录集合内每个node对象的前后关系实现一个堆栈,本质是使用了CFMutableDictionaryRef来进行对象的存储,这个集合管理了对象的出栈,入栈以及排序,相关的方法依次有</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将一个node对象插到队列最前面</span></span><br><span class="line">- (<span class="keyword">void</span>)insertNodeAtHead:(_YYLinkedMapNode *)node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个node放到队列最前面</span></span><br><span class="line">- (<span class="keyword">void</span>)bringNodeToHead:(_YYLinkedMapNode *)node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除掉指定node</span></span><br><span class="line">- (<span class="keyword">void</span>)removeNode:(_YYLinkedMapNode *)node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将最后一个个node移除</span></span><br><span class="line">- (_YYLinkedMapNode *)removeTailNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除队列</span></span><br><span class="line">- (<span class="keyword">void</span>)removeAll</span><br></pre></td></tr></table></figure><ul><li>以上是YYMemoryCache中两个重要的类,在每次给memoryCache发送<code>setObject:forkey:</code>或者<code>objectForKey:</code>消息的时候都会更新对应的linkedMapNode对象的时间戳属性,并且把该对象放到队列的最前面,从而调整了缓存中对象的顺序.</li></ul><h3 id="内存缓存对象释放控制"><a href="#内存缓存对象释放控制" class="headerlink" title="内存缓存对象释放控制"></a>内存缓存对象释放控制</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_releaseAsynchronously) &#123;</span><br><span class="line">       <span class="built_in">dispatch_queue_t</span> queue = _releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line">       <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">           <span class="built_in">CFRelease</span>(holder); <span class="comment">// hold and release in specified queue</span></span><br><span class="line">       &#125;);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123;</span><br><span class="line">       <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">           <span class="built_in">CFRelease</span>(holder); <span class="comment">// hold and release in specified queue</span></span><br><span class="line">       &#125;);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="built_in">CFRelease</span>(holder);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>我们知道对象的创建需要分配内存空间,大量的创建对象会比较消耗性能,同样大量的对象的释放操作也是比较消耗性能的,所以在YYMemeryCache中提供了可以异步,并且选择子线程进行对象的释放的选项,这里释放操作比较巧妙我不是很理解,记录一下.   我暂时的理解是利用了block能够捕获外部变量,导致当执行到<code>dispatch_async(queue, ^{</code>虽然node已经被置为nil了,但是node对象并不会被马上释放(被block所捕获),等到切换到相应线程中以后对这个node对象发消息,编译器发现这个node已经被置空了,  才会马上释放该对象.</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_lru-&gt;_totalCount &gt; _countLimit) &#123;</span><br><span class="line">        _YYLinkedMapNode *node = [_lru removeTailNode];</span><br><span class="line">        <span class="keyword">if</span> (_lru-&gt;_releaseAsynchronously) &#123;</span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line">            <span class="comment">//node并不会马上释放,因为被block捕获了</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            <span class="comment">//在这里可以实现在异步线程中释放对象?</span></span><br><span class="line">                [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="缓存上限的控制"><a href="#缓存上限的控制" class="headerlink" title="缓存上限的控制"></a>缓存上限的控制</h3><ul><li>在内存缓存中作者采用了轮询的方式来控制内存缓存中缓存上限,缓存个数以及过期时间,默认轮询时间是5秒,并且次轮训操作放到异步线程中,采用低优先级以获取较高的性能</li><li>作者定义了三个方法<code>- _trimToCost:</code>,<code>-_trimToCount:</code>,<code>-_trimToAge:</code>来分别限制最大缓存字节数,对象个数,缓存时间,我们拿其中一个来看其中的知识点</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_trimToCost:(<span class="built_in">NSUInteger</span>)costLimit &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> finish = <span class="literal">NO</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    <span class="keyword">if</span> (costLimit == <span class="number">0</span>) &#123;</span><br><span class="line">        [_lru removeAll];</span><br><span class="line">        finish = <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_lru-&gt;_totalCost &lt;= costLimit) &#123;</span><br><span class="line">        finish = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">    <span class="keyword">if</span> (finish) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *holder = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    <span class="keyword">while</span> (!finish) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pthread_mutex_trylock函数是pthread_mutex_lock函数的非阻塞版本,也可以用来加锁</span></span><br><span class="line">    与pthread_mutex_lock的区别是:trylock如果没有获取到锁就会立刻返回不会阻塞当前线程,获取锁成功会返回<span class="number">0</span>,否则返回其他值来说明锁的状态.</span><br><span class="line">    但是lock如果没有获取到锁会一直等待从而发生阻塞.</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取锁成功后加锁</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_trylock(&amp;_lock) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_lru-&gt;_totalCost &gt; costLimit) &#123;</span><br><span class="line">                _YYLinkedMapNode *node = [_lru removeTailNode];</span><br><span class="line">                <span class="keyword">if</span> (node) [holder addObject:node];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                finish = <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取锁失败将当前线程挂起10ms</span></span><br><span class="line">            usleep(<span class="number">10</span> * <span class="number">1000</span>); <span class="comment">//10 ms</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里holder虽然是临时变量,超过函数&#123;&#125;范围后以后会被释放掉.</span></span><br><span class="line">    <span class="comment">//这里同样是利用了block的捕获变量能力来达到后台线程释放对象.</span></span><br><span class="line">    <span class="keyword">if</span> (holder.count) &#123;</span><br><span class="line">        <span class="built_in">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            [holder count]; <span class="comment">// release in queue</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上就是YYMemoryCache中的关键技术点和实现思路,从中学习到很多有用的知识,例如对象的释放选择性的放到子线程中,iru淘汰算法的实现,类之间的设计思路以及作者严谨的代码风格.以后还会分析YYDiskCache的具体实现.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;YYCache-tips&quot;&gt;&lt;a href=&quot;#YYCache-tips&quot; class=&quot;headerlink&quot; title=&quot;YYCache  tips&quot;&gt;&lt;/a&gt;YYCache  tips&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;之前YYKit刚开源的时候就粗
      
    
    </summary>
    
      <category term="iOS源码分析" scheme="http://yincongxiao.top/categories/iOS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>YYDiskCache study</title>
    <link href="http://yincongxiao.top/2016/11/15/YYDiskCache-study/"/>
    <id>http://yincongxiao.top/2016/11/15/YYDiskCache-study/</id>
    <published>2016-11-15T02:16:23.000Z</published>
    <updated>2019-05-16T11:52:21.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="YYDiskCache"><a href="#YYDiskCache" class="headerlink" title="YYDiskCache"></a>YYDiskCache</h2><ul><li>先来看指定构造器中都初始化了哪些变量.</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">             inlineThreshold:(<span class="built_in">NSUInteger</span>)threshold &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="comment">//这里并不是直接初始化了一个存储对象的cache,</span></span><br><span class="line"><span class="comment">//而是从一个全局容器中取出与path对应的cache对象,    </span></span><br><span class="line">    YYDiskCache *globalCache = _YYDiskCacheGetGlobal(path);</span><br><span class="line">    <span class="keyword">if</span> (globalCache) <span class="keyword">return</span> globalCache;</span><br><span class="line">    </span><br><span class="line">    YYKVStorageType type;</span><br><span class="line">    <span class="keyword">if</span> (threshold == <span class="number">0</span>) &#123;</span><br><span class="line">        type = YYKVStorageTypeFile;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (threshold == <span class="built_in">NSUIntegerMax</span>) &#123;</span><br><span class="line">        type = YYKVStorageTypeSQLite;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        type = YYKVStorageTypeMixed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    YYKVStorage *kv = [[YYKVStorage alloc] initWithPath:path type:type];</span><br><span class="line">    <span class="keyword">if</span> (!kv) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    _kv = kv;</span><br><span class="line">    _path = path;</span><br><span class="line">    _lock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    _queue = dispatch_queue_create(<span class="string">"com.ibireme.cache.disk"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    _inlineThreshold = threshold;</span><br><span class="line">    _countLimit = <span class="built_in">NSUIntegerMax</span>;</span><br><span class="line">    _costLimit = <span class="built_in">NSUIntegerMax</span>;</span><br><span class="line">    _ageLimit = DBL_MAX;</span><br><span class="line">    _freeDiskSpaceLimit = <span class="number">0</span>;</span><br><span class="line">    _autoTrimInterval = <span class="number">60</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> _trimRecursively];</span><br><span class="line">    _YYDiskCacheSetGlobal(<span class="keyword">self</span>);</span><br><span class="line">    </span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(_appWillBeTerminated) name:<span class="built_in">UIApplicationWillTerminateNotification</span> object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首相我们来分析第一行代码<code>YYDiskCache *globalCache = _YYDiskCacheGetGlobal(path);</code>做了什么,</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> YYDiskCache *_YYDiskCacheGetGlobal(<span class="built_in">NSString</span> *path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//这里进行全局的初始化操作,并且只做一次.</span></span><br><span class="line">    _YYDiskCacheInitGlobal();</span><br><span class="line">    <span class="comment">//利用gcd的信号量机制加锁,保证线程安全.</span></span><br><span class="line">    dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="keyword">id</span> cache = [_globalInstances objectForKey:path];</span><br><span class="line">    dispatch_semaphore_signal(_globalInstancesLock);</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _YYDiskCacheInitGlobal() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="comment">//初始化锁</span></span><br><span class="line">        _globalInstancesLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//初始化保存chache对象的NSMapTable对象,</span></span><br><span class="line">        _globalInstances = [[<span class="built_in">NSMapTable</span> alloc] initWithKeyOptions:<span class="built_in">NSPointerFunctionsStrongMemory</span> valueOptions:<span class="built_in">NSPointerFunctionsWeakMemory</span> capacity:<span class="number">0</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面初始化中用来保存cache的容器使用到了NSMapTable对象,<code>NSMapTable</code>是在iOS6以后推出的类似NSMutableDictionary的容器类,它与NSDictionary的区别是<code>NSMapTable</code>可以指定使用什么策略来持有所存储对象的键和值,在这里选择的是key使用强引用,值使用若引用,也就是这个mapTable并不会使所存储的cache对象retainCount增加,并且当所存储的cache对象被释放后,mapTable会自动将cache移除.同时期推出的还有<code>NSHashTable</code>详细学习可以参看<a href="http://www.jianshu.com/p/de71385930ba" target="_blank" rel="noopener">这篇文章</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;YYDiskCache&quot;&gt;&lt;a href=&quot;#YYDiskCache&quot; class=&quot;headerlink&quot; title=&quot;YYDiskCache&quot;&gt;&lt;/a&gt;YYDiskCache&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;先来看指定构造器中都初始化了哪些变量.&lt;/li&gt;
&lt;/u
      
    
    </summary>
    
      <category term="iOS源码分析" scheme="http://yincongxiao.top/categories/iOS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>GCD-dispatch_source</title>
    <link href="http://yincongxiao.top/2016/07/02/GCD-dispatch-source/"/>
    <id>http://yincongxiao.top/2016/07/02/GCD-dispatch-source/</id>
    <published>2016-07-02T03:08:47.000Z</published>
    <updated>2019-05-16T11:52:21.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GCD-dispatch-source"><a href="#GCD-dispatch-source" class="headerlink" title="GCD-dispatch_source"></a>GCD-dispatch_source</h1><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p> <code>dispatch_source</code> 并不像<code>queue</code>,<code>async</code>等常见, 它是GCD中一种强大的事件 api<br>它是BSD系内核惯有功能<a href="https://en.wikipedia.org/wiki/Kqueue" target="_blank" rel="noopener">kqueue</a>的包装,它可以用来监听系统或者我们自定义的各种事件,它的强大之处是无论在任何线程上都可以通过函数<code>dispatch_source_merge_data()</code>来执行之前设置的回调句柄(理解为block)</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h3 id="创建事件源"><a href="#创建事件源" class="headerlink" title="创建事件源"></a>创建事件源</h3><p>先看代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    _source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_queue_create(&quot;myqueue&quot;, DISPATCH_QUEUE_CONCURRENT));</span><br><span class="line">    dispatch_resume(_source);</span><br><span class="line">    dispatch_source_set_event_handler(_source, ^&#123;</span><br><span class="line">        unsigned long receive = dispatch_source_get_data(_source);</span><br><span class="line">        NSLog(@&quot;%zd&quot;,receive);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; i ++) &#123;</span><br><span class="line">            dispatch_source_merge_data(_source, 2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们通过<code>dispatch_queue_create()</code>创建了一个<code>source</code>这个函数接受四个参数</p><ul><li>dispatch_source_type_t type //事件类型</li><li>uintptr_t handle, //可以理解为句柄、索引或id，假如要监听进程，需要传入进程的ID</li><li><p>unsigned long mask //可以理解为描述，提供更详细的描述，让它知道具体要监听什么</p></li><li><p>dispatch_queue_t _Nullable queue //自定义源需要的一个队列，用来处理所有的响应句柄（block）</p></li></ul><p>chat: dispatch_source的事件类型.</p><table><thead><tr><th>type类型</th><th>用途</th></tr></thead><tbody><tr><td>DISPATCH_SOURCE_TYPE_DATA_ADD</td><td>自定义的事件，变量增加</td></tr><tr><td>DISPATCH_SOURCE_TYPE_DATA_OR</td><td>自定义的事件，变量OR</td></tr><tr><td>DISPATCH_SOURCE_TYPE_MACH_SEND</td><td>MACH端口发送</td></tr><tr><td>DISPATCH_SOURCE_TYPE_MACH_RECV</td><td>MACH端口接收</td></tr><tr><td>DISPATCH_SOURCE_TYPE_PROC</td><td>进程监听,如进程的退出、创建一个或更多的子线程、进程收到UNIX信号</td></tr><tr><td>DISPATCH_SOURCE_TYPE_READ</td><td>IO操作，如对文件的操作、socket操作的读响应</td></tr><tr><td>DISPATCH_SOURCE_TYPE_SIGNAL</td><td>接收到UNIX信号时响应</td></tr><tr><td>DISPATCH_SOURCE_TYPE_TIMER</td><td>定时器</td></tr><tr><td></td></tr><tr><td>DISPATCH_SOURCE_TYPE_VNODE</td><td>文件状态监听，文件被删除、移动、重命名</td></tr><tr><td>DISPATCH_SOURCE_TYPE_WRITE</td><td>IO操作，如对文件的操作、socket操作的写响应</td></tr></tbody></table><p>还有一点要注意的是,默认我们创建的source是被suspend的,所以我们需要手动的调用<code>dispatch_resume(source)</code>恢复它.</p><p><code>dispatch_source_set_event_handler()</code>函数用来设置souce事件触发的回调,它接受两个参数,我们设置的source和一个会掉的block</p><p><code>dispatch_source_merge_data(_source, 2);</code>来手动触发source的事件源,第二个参数不能是 &lt;= 0 的数, 否则不能得到回调.</p><p><code>dispatch_source_get_data()</code>得到事件源传递来的数据.</p><p>如果我们使用<code>DISPATCH_SOURCE_TYPE_DATA_ADD</code>类型的事件源,并且我们<em>在短时间内</em>频繁的调用<code>dispatch_source_merge_data()</code>函数,之前注册的事件源回调并不会相应的调用多次,而只是调用一次,并且<code>dispatch_source_get_data()</code>得到的结果是多次的参数和20.<br>但是如果中间间隔时间长的话就会多次调用,每次传递值是2.</p><p>其他有用的函数还有:</p><table><thead><tr><th>func</th><th>用途</th></tr></thead><tbody><tr><td>voird dispatch_source_set_cancel_handler(dispatch_source_t source,dispatch_block_t _Nullable handler)</td><td>dispatch源取消时调用的block，一般用于关闭文件或socket等，释放相关资源</td></tr><tr><td>long dispatch_source_testcancel(dispatch_source_t source)</td><td>检测是否dispatch源被取消，如果返回非0值则表明dispatch源已经被取消</td></tr><tr><td>void dispatch_source_set_registration_handler(dispatch_source_t source, dispatch_block_t registration_handler);</td><td>可用于设置dispatch源启动时调用block，调用完成后即释放这个block。也可在dispatch源运行当中随时调用这个函数</td></tr><tr><td>dispatch_suspend(queue)</td><td>挂起queue</td></tr><tr><td>dispatch_resume(source)</td><td>分派源创建时默认处于暂停状态，在分派源分派处理程序之前必须先恢复</td></tr><tr><td>uintptr_t dispatch_source_get_handle(dispatch_source_t source)</td><td>得到dispatch源创建，即调用dispatch_source_create的第二个参数</td></tr><tr><td>unsigned long dispatch_source_get_mask(dispatch_source_t source)</td><td>得到dispatch源创建，即调用dispatch_source_create的第三个参数</td></tr><tr><td>得到dispatch源创建，即调用dispatch_source_create的第三个参数</td><td>取消dispatch源的事件处理–即不再调用block。如果调用dispatch_suspend只是暂停dispatch源。</td></tr></tbody></table><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>倒计时label</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@implementation TimerLabel &#123;</span><br><span class="line">    dispatch_source_t _timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithTimeInterval:(NSUInteger)interval &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        self.numberOfLines = 1;</span><br><span class="line">        __weak CountLabel *weakSelf = self;</span><br><span class="line">        __block NSUInteger timeout = interval;</span><br><span class="line">        dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">        _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);</span><br><span class="line">        dispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0);</span><br><span class="line">        dispatch_source_set_event_handler(_timer, ^&#123;</span><br><span class="line">            if(timeout&lt;=0)&#123;</span><br><span class="line">                dispatch_source_cancel(_timer);</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    weakSelf.text = @&quot;ok now&quot;;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                NSUInteger seconds = timeout % (timeout + 1);</span><br><span class="line">                NSString *strTime = [NSString stringWithFormat:@&quot;剩余:%.2lu s&quot;, seconds];</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    [UIView beginAnimations:nil context:nil];</span><br><span class="line">                    [UIView setAnimationDuration:1];</span><br><span class="line">                    weakSelf.text = strTime;</span><br><span class="line">                    [weakSelf sizeToFit];</span><br><span class="line">                    [UIView commitAnimations];</span><br><span class="line">                &#125;);</span><br><span class="line">                timeout--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)start &#123;</span><br><span class="line">    dispatch_resume(_timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GCD-dispatch-source&quot;&gt;&lt;a href=&quot;#GCD-dispatch-source&quot; class=&quot;headerlink&quot; title=&quot;GCD-dispatch_source&quot;&gt;&lt;/a&gt;GCD-dispatch_source&lt;/h1&gt;&lt;h3 i
      
    
    </summary>
    
      <category term="iOSTips" scheme="http://yincongxiao.top/categories/iOSTips/"/>
    
    
  </entry>
  
  <entry>
    <title>dispatch_group_t 使用详解</title>
    <link href="http://yincongxiao.top/2016/05/10/dispatch-group-t-%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yincongxiao.top/2016/05/10/dispatch-group-t-使用详解/</id>
    <published>2016-05-10T01:10:48.000Z</published>
    <updated>2019-05-16T11:52:21.688Z</updated>
    
    <content type="html"><![CDATA[<ul><li>通常我们执行耗时操作会放到子线程中并发执行,这个过程中我们可能想知道各个任务全部执行完毕的时刻,当然我们可以通过记录一些标志位等手段来达到要求,但是可能步骤会比较复杂.强大的GCD中的<code>dispatch_group_t</code>可以轻松帮我们达到目的.</li></ul><h5 id="我们先来看group中的api"><a href="#我们先来看group中的api" class="headerlink" title="我们先来看group中的api"></a>我们先来看group中的api</h5><ul><li><p>dispatch_group_async</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//将block(任务)提交到指定的队列中,并且将次任务放到(关联)指定的group,block将异步执行.</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_async</span><span class="params">(<span class="keyword">dispatch_group_t</span> group,<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>,<span class="keyword">dispatch_block_t</span> block)</span></span>;</span><br><span class="line"> <span class="comment">//上面方法的函数版本.接受一个函数指针.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_async_f</span><span class="params">(<span class="keyword">dispatch_group_t</span> group,<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>,<span class="keyword">void</span> *_Nullable context,<span class="keyword">dispatch_function_t</span> work)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>dispatch_group_wait</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个方法会同步的等,接受一个timeout,group的任务全部完成或者超时以后会返回,返回值为0代表任务完成,非0代表超时.</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dispatch_group_wait</span><span class="params">(<span class="keyword">dispatch_group_t</span> group,<span class="keyword">dispatch_time_t</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>dispatch_group_notify</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当group中的任务都完成以后会执行block.注意这句代码要加到所有任务提交之后才管用.参数queue代表block会提交到哪个队列中.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_notify</span><span class="params">(<span class="keyword">dispatch_group_t</span> group,<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>,<span class="keyword">dispatch_block_t</span> block)</span></span>;</span><br><span class="line"><span class="comment">//上面方法的函数版本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_notify_f</span><span class="params">(<span class="keyword">dispatch_group_t</span> group,<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>,<span class="keyword">void</span> *_Nullable context,<span class="keyword">dispatch_function_t</span> work)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>dispatch_group_enter</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用这个方法指定一个操作将要加到group中,用来替代`dispatch_group_async`,注意它只能和`dispatch_group_leave`配对使用.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_enter</span><span class="params">(<span class="keyword">dispatch_group_t</span> group)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>dispatch_group_leave</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定一个任务完成了.只能和`dispatch_group_enter`配对使用.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_leave</span><span class="params">(<span class="keyword">dispatch_group_t</span> group)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h5 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h5><h6 id="dispatch-group-async"><a href="#dispatch-group-async" class="headerlink" title="dispatch_group_async"></a>dispatch_group_async</h6> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.GCDDemo.queue"</span>,DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:<span class="number">2.0</span>];</span><br><span class="line">        NSLog(@<span class="string">"first download task success! %@"</span>,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:<span class="number">1.0</span>];</span><br><span class="line">        NSLog(@<span class="string">"second download task success! %@"</span>,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, concurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"begin task three! %@"</span>,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    输出台:</span><br><span class="line">   second download task success! &lt;NSThread: <span class="number">0x600000279c80</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"> first download task success! &lt;NSThread: <span class="number">0x6080002674c0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line">begin task three! &lt;NSThread: <span class="number">0x6080002674c0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure><h6 id="dispatch-group-enter-amp-dispatch-group-leave"><a href="#dispatch-group-enter-amp-dispatch-group-leave" class="headerlink" title="dispatch_group_enter &amp; dispatch_group_leave"></a>dispatch_group_enter &amp; dispatch_group_leave</h6><ul><li>个人感觉这种方式比<code>dispatch_group_async</code>更加灵活.比如我们可以在任务的完成回调里面写dispatch_group_leave().</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.GCDDemo.concurrentQueue"</span>,DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.GCDDemo.serialQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:<span class="number">2.0</span>];</span><br><span class="line">        NSLog(@<span class="string">"first download task success! %@"</span>,[NSThread currentThread]);</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    dispatch_async(serialQueue, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:<span class="number">2.0</span>];</span><br><span class="line">        NSLog(@<span class="string">"second download task success! %@"</span>,[NSThread currentThread]);</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    dispatch_async(serialQueue, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:<span class="number">2.0</span>];</span><br><span class="line">        NSLog(@<span class="string">"three download task success! %@"</span>,[NSThread currentThread]);</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//超时处理.</span></span><br><span class="line">    <span class="keyword">long</span> result = dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, <span class="number">1.0</span> * NSEC_PER_SEC));</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        NSLog(@<span class="string">"success"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        NSLog(@<span class="string">"time out!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, concurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"begin task three! %@"</span>,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//输出台:</span></span><br><span class="line">time out!</span><br><span class="line"> first download task success! &lt;NSThread: <span class="number">0x608000277200</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line">second download task success! &lt;NSThread: <span class="number">0x608000270c40</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"> three download task success! &lt;NSThread: <span class="number">0x608000270c40</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line">begin task three! &lt;NSThread: <span class="number">0x608000277200</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line">注意我的任务<span class="number">1</span>放在了并发队列中,任务<span class="number">2</span>,和任务<span class="number">3</span>放在了串行队列中,所以你看到的打印顺序是任务<span class="number">1</span>和任务<span class="number">2</span>几乎同时打印,任务<span class="number">3</span>等<span class="number">2</span>秒后打印,(在任务<span class="number">2</span>之后).</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;通常我们执行耗时操作会放到子线程中并发执行,这个过程中我们可能想知道各个任务全部执行完毕的时刻,当然我们可以通过记录一些标志位等手段来达到要求,但是可能步骤会比较复杂.强大的GCD中的&lt;code&gt;dispatch_group_t&lt;/code&gt;可以轻松帮我们达到目
      
    
    </summary>
    
      <category term="iOSTips" scheme="http://yincongxiao.top/categories/iOSTips/"/>
    
    
  </entry>
  
  <entry>
    <title>dispatch_barrier使用详解</title>
    <link href="http://yincongxiao.top/2016/05/02/dispatch-barrier%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yincongxiao.top/2016/05/02/dispatch-barrier使用详解/</id>
    <published>2016-05-02T03:08:47.000Z</published>
    <updated>2019-05-16T11:52:21.687Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>多线程开发过程中,我们如果想在前面的任务完成后再去执行后面的某些操作,我们可以采用<code>dispatch_barrier_async</code>来轻松实现</p></li><li><p>dispatch_barrier是跟<code>dipatch_async/dispatch_sync</code> 相似的api,用来将任务提交到指定队列中,它的使用注意点:queue<strong>必须</strong>是<code>DISPATCH_QUEUE_CONCURRENT</code>类型的.queue如果是global或者不是<code>DISPATCH_QUEUE_CONCURRENT</code>类型的其他queue,它的作用就和普通的<code>dipatch_async/dispatch_sync</code>一样.</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.GCDDemo.concurrentQueue"</span>,DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++) &#123;</span><br><span class="line">        dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:<span class="number">1.0</span>];</span><br><span class="line">            NSLog(@<span class="string">"download task %d successed!"</span>,i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_barrier_async(concurrentQueue, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:<span class="number">2.0</span>];</span><br><span class="line">        NSLog(@<span class="string">"barrier blcok success!"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:<span class="number">1.0</span>];</span><br><span class="line">        NSLog(@<span class="string">"upload task successed!"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//输出台:</span></span><br><span class="line">download task <span class="number">2</span> successed!</span><br><span class="line">download task <span class="number">1</span> successed!</span><br><span class="line">download task <span class="number">0</span> successed!</span><br><span class="line">barrier blcok success!</span><br><span class="line">upload task successed!</span><br></pre></td></tr></table></figure><ul><li>假如queue是global queue</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> globalQueue = dispatch_get_global_queue(<span class="number">0</span>, DISPATCH_QUEUE_PRIORITY_DEFAULT);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++) &#123;</span><br><span class="line">        dispatch_async(globalQueue, ^&#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:<span class="number">1.0</span>];</span><br><span class="line">            NSLog(@<span class="string">"download task %d successed!"</span>,i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_barrier_async(globalQueue, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:<span class="number">2.0</span>];</span><br><span class="line">        NSLog(@<span class="string">"barrier blcok success!"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(globalQueue, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:<span class="number">1.0</span>];</span><br><span class="line">        NSLog(@<span class="string">"upload task successed!"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//输出台:</span></span><br><span class="line">download task <span class="number">1</span> successed!</span><br><span class="line">download task <span class="number">0</span> successed!</span><br><span class="line">download task <span class="number">2</span> successed!</span><br><span class="line">upload task successed!</span><br><span class="line">barrier blcok success!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;多线程开发过程中,我们如果想在前面的任务完成后再去执行后面的某些操作,我们可以采用&lt;code&gt;dispatch_barrier_async&lt;/code&gt;来轻松实现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;dispatch_barrier是跟&lt;code&gt;dipat
      
    
    </summary>
    
      <category term="iOSTips" scheme="http://yincongxiao.top/categories/iOSTips/"/>
    
    
  </entry>
  
  <entry>
    <title>CoreAnimation-CALayer(四)</title>
    <link href="http://yincongxiao.top/2016/02/06/CoreAnimation-CALayer-%E5%9B%9B/"/>
    <id>http://yincongxiao.top/2016/02/06/CoreAnimation-CALayer-四/</id>
    <published>2016-02-06T08:40:25.000Z</published>
    <updated>2019-05-16T11:52:21.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CoreAnimation-CALayer-四"><a href="#CoreAnimation-CALayer-四" class="headerlink" title="CoreAnimation-CALayer(四)"></a>CoreAnimation-CALayer(四)</h1><h2 id="Animation的原理"><a href="#Animation的原理" class="headerlink" title="Animation的原理"></a>Animation的原理</h2><p>我们在前面讲了在修改非根层的layer的animatable属性时会产生隐式动画,那为什么直接修改view.layer的animatable属性并不能产生动画,而是需要放在<code>+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations</code>的animationBlock中才会产生动画呢?</p><p>前面文章讲了UIView和CALayer的关系,一个UIView内部默认有一个layer(rootLayer),layer负责绘制,view是layer的delegate.<br>其实我们在修改layer的animatable属性时,layer会调用它的delegate的<code>- (nullable id&lt;CAAction&gt;)actionForLayer:(CALayer *)layer forKey:(NSString *)event</code>方法,这个方法的返回值有三种情况</p><ul><li>返回nil</li><li>返回(NSNull * )对象</li><li><p>返回一个 (id<caaction>)的对象.</caaction></p><p>对这三种情况会产生三种效果:返回值为nil,就会产生<strong>隐式动画</strong>,返回值为(NSNull <em>)没有动画效果,第三种情况是使用返回的(id<caaction>)对象产生一个CAAnimation,并且调用自己的addAnimation:方法进行动画.<br>直接修改非根层layer的animatable属性属于第一种,因为这个layer没有delegate对象,该方法返回nil,所以就有了隐式动画<br>直接修改根层layer的属性又分为两种情况,第一种在animationBlock外部直接修改,这里就返回NSNull </caaction></em>,第二种在animationBlock内部修改,这里会返回(id<caaction>)产生动画,这里我们需要注意直接修改UIView的属性例如transform,其实是直接修改的它内部的layer的transform属性!<br>我们来验证一下</caaction></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CustomLayer.m</span></span><br><span class="line">@implementation CustomLayer</span><br><span class="line">- (<span class="keyword">void</span>)setPosition:(CGPoint)position &#123;</span><br><span class="line">    id action = nil;</span><br><span class="line">    <span class="keyword">if</span> ([self.delegate respondsToSelector:@selector(actionForLayer:forKey:)]) &#123;</span><br><span class="line">        action = [self.delegate actionForLayer:self forKey:@<span class="string">"positon"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (action == nil) &#123;</span><br><span class="line">        NSLog(@<span class="string">"action == nil"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([action isKindOfClass:[NSNull class]]) &#123;</span><br><span class="line">        NSLog(@<span class="string">"action is null"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([action conformsToProtocol:@protocol(CAAction)]) &#123;</span><br><span class="line">        NSLog(@<span class="string">"action conformsToProtocol:@protocol(CAAction)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        [super setPosition:position];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"><span class="comment">//CustomView.m</span></span><br><span class="line">@implementation CustomView</span><br><span class="line">+ (Class)layerClass &#123;</span><br><span class="line">    <span class="keyword">return</span> [CustomLayer class];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"><span class="comment">//ViewController.m</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    _cV = [[CustomView alloc] initWithFrame:CGRectMake(<span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line">    _cV.backgroundColor = [UIColor redColor];</span><br><span class="line">    [self.view addSubview:_cV];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    _cV.layer.position = CGPointMake(<span class="number">150</span>, <span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里直接修改的是根层的position,输出台打印结果是: action is null</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    _custLayer = [CustomLayer layer];</span><br><span class="line">    _custLayer.bounds = CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">    _custLayer.position = CGPointMake(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">    _custLayer.backgroundColor = [UIColor redColor].CGColor;</span><br><span class="line">    [self.view.layer addSublayer:_custLayer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    _custLayer.position = CGPointMake(<span class="number">350</span>, <span class="number">350</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里直接修改非根层layer的属性,打印结果是action == nil</p><h4 id="CALayer的-presentationLayer-和-modelLayer"><a href="#CALayer的-presentationLayer-和-modelLayer" class="headerlink" title="CALayer的 presentationLayer 和 modelLayer"></a>CALayer的 presentationLayer 和 modelLayer</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    _customView = [[UIView alloc] initWithFrame:CGRectMake(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line">    _customView.backgroundColor = [UIColor redColor];</span><br><span class="line">    [self.view addSubview:_customView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    CABasicAnimation *animation = [CABasicAnimation animation];</span><br><span class="line">    animation.keyPath = @<span class="string">"position"</span>;</span><br><span class="line">    animation.duration = <span class="number">0.5</span>;</span><br><span class="line">    animation.toValue = [NSValue valueWithCGPoint:CGPointMake(<span class="number">200</span>, <span class="number">200</span>)];</span><br><span class="line">    [_customView.layer addAnimation:animation forKey:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://o7vzr7y09.bkt.clouddn.com/transform.gif" alt><br>我们看到动画完成后又回到了原来的位置,这是为什么呢?<br>在CALayer内部，它控制着两个属性：presentationLayer 展示层(以下称为P)和modelLayer（模型层以下称为M）。</p><p>P只负责显示，M只负责数据的存储和获取。我们对layer的各种属性赋值比如frame，<strong>实际上是直接对M的属性赋值</strong>，而P将在每一次屏幕刷新的时候回到M的状态。比如此时M的状态是1，P的状态也是1，然后我们把M的状态改为2，那么此时P还没有过去，也就是我们看到的状态P还是1，在下一次屏幕刷新的时候P才变为2。而我们几乎感知不到两次屏幕刷新之间的间隙，所以感觉就是我们一对M赋值，P就过去了。P就像是瞎子，M就像是瘸子，瞎子背着瘸子，瞎子每走一步（也就是每次屏幕刷新的时候）都要去问瘸子应该怎样走（这里的走路就是绘制内容到屏幕上），瘸子没法走，只能指挥瞎子背着自己走。可以简单的理解为：一般情况下，任意时刻P都会回到M的状态。</p><p>而当一个CAAnimation（以下称为A）加到了layer上面后，A就把M从P身上挤下去了。现在P背着的是A，P同样在每次屏幕刷新的时候去问他背着的那个家伙，A就指挥它从fromValue到toValue来改变值。而动画结束后，A会自动被移除，这时P没有了指挥，就只能大喊“M你在哪”，M说我还在原地没动呢，于是P就顺声回到M的位置了。这就是为什么动画结束后我们看到这个视图又回到了原来的位置，是因为我们看到在移动的是P，而指挥它移动的是A，M永远停在原来的位置没有动，动画结束后A被移除，P就回到了M的怀里。</p><p>我们不想动画完成以后再回到原来位置怎么办呢?<code>CAAniamtion</code>基类中提供了<code>removedOnCompletion</code>,这个属性默认是YES,我们需要将它置为NO,同时将<code>fillMode</code>设置为<code>kCAFillModeForwards</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    CABasicAnimation *animation = [CABasicAnimation animation];</span><br><span class="line">    animation.keyPath = @<span class="string">"position"</span>;</span><br><span class="line">    animation.duration = <span class="number">0.5</span>;</span><br><span class="line">    animation.removedOnCompletion = NO;</span><br><span class="line">    animation.fillMode = kCAFillModeForwards;</span><br><span class="line">    animation.toValue = [NSValue valueWithCGPoint:CGPointMake(<span class="number">200</span>, <span class="number">200</span>)];</span><br><span class="line">    [_customView.layer addAnimation:animation forKey:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://o7vzr7y09.bkt.clouddn.com/transform1.gif" alt><br>这两个方法其实是coreAnimation将presentationLayer属性一直保持在动画结束后的状态,而实际的modelLayer属性并没有真正发生改变. 我们如果把customView换成UIButton的话,在动画完成以后点击按钮是不能响应的.点击按钮动画前的位置却能响应!下面是解决办法.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    <span class="comment">//注意: 关于toValue 和 fromValue 设置了这两个值以后presentationLayer的值(也就是动画轨迹)实际上是</span></span><br><span class="line">    <span class="comment">// presentationLayer原始值 -&gt; fromValue -&gt; toValue,动画完成后toValue -&gt; modelLayer的值.</span></span><br><span class="line">    NSLog(@<span class="string">"presentationLayer.position: %@"</span>,NSStringFromCGPoint(_customView.layer.presentationLayer.position));</span><br><span class="line">    NSLog(@<span class="string">"modelLayer.position: %@"</span>,NSStringFromCGPoint(_customView.layer.modelLayer.position));</span><br><span class="line">    _customView.layer.position = CGPointMake(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">    NSLog(@<span class="string">"presentationLayer.position: %@"</span>,NSStringFromCGPoint(_customView.layer.presentationLayer.position));</span><br><span class="line">    NSLog(@<span class="string">"modelLayer.position: %@"</span>,NSStringFromCGPoint(_customView.layer.modelLayer.position));</span><br><span class="line">    <span class="comment">//presentationLayer.position 经历了 (150, 150) -&gt; (150, 150) -&gt; (200, 200) 的过程</span></span><br><span class="line">    CABasicAnimation *animation = [CABasicAnimation animation];</span><br><span class="line">    animation.keyPath = @<span class="string">"position"</span>;</span><br><span class="line">    animation.duration = <span class="number">0.5</span>;</span><br><span class="line">    animation.removedOnCompletion = NO;</span><br><span class="line">    animation.fillMode = kCAFillModeForwards;</span><br><span class="line">    animation.fromValue = [NSValue valueWithCGPoint:CGPointMake(<span class="number">150</span>, <span class="number">150</span>)];</span><br><span class="line">    [_customView.layer addAnimation:animation forKey:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子实际上将<code>animation.fromValue = [NSValue valueWithCGPoint:CGPointMake(150, 150)];</code>这句注释掉也是没问题的,这样既能维持动画完成后状态,view的点击事件不受影响!具体的原理在代码里.<br><img src="http://o7vzr7y09.bkt.clouddn.com/transform1.gif" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CoreAnimation-CALayer-四&quot;&gt;&lt;a href=&quot;#CoreAnimation-CALayer-四&quot; class=&quot;headerlink&quot; title=&quot;CoreAnimation-CALayer(四)&quot;&gt;&lt;/a&gt;CoreAnimation-CA
      
    
    </summary>
    
      <category term="iOSTips" scheme="http://yincongxiao.top/categories/iOSTips/"/>
    
    
  </entry>
  
  <entry>
    <title>CoreAnimation-CALayer(三)</title>
    <link href="http://yincongxiao.top/2016/02/01/CoreAnimation-CALayer-%E4%B8%89/"/>
    <id>http://yincongxiao.top/2016/02/01/CoreAnimation-CALayer-三/</id>
    <published>2016-01-31T16:06:02.000Z</published>
    <updated>2019-05-16T11:52:21.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CoreAnimation-CALayer-三"><a href="#CoreAnimation-CALayer-三" class="headerlink" title="CoreAnimation-CALayer(三)"></a>CoreAnimation-CALayer(三)</h1><h2 id="CASharpLayer"><a href="#CASharpLayer" class="headerlink" title="CASharpLayer"></a>CASharpLayer</h2><p><code>CASharpLayer</code>是一个通过矢量图形而不是bitmap（位图）来绘制的CALayer子类.我们可以指定<code>CGPathRef</code>来快速地创建各种形状的layer,CASharpLayer里面有各种<code>Animatable</code>的属性,通过这些属性我们可以实现一些很有意思的动画效果,例如<a href="http://asnail.xyz/2016/01/10/CoreAnimation-CALayer-二/" target="_blank" rel="noopener">前文</a>的圆环进度条,还有下面的浮动动画.</p><p>如果我们使用普通的CALayer通过设置绘制路径也能实现不同形状的layer,但是是用CASharpLayer有以下好处:</p><ul><li>渲染快速。CAShapeLayer使用了硬件加速，绘制同一图形会比用Core Graphics快很多。</li><li>高效使用内存。一个CAShapeLayer不需要像普通CALayer一样创建一个寄宿图形（backing image），所以无论有多大，都不会占用太多的内存。</li><li>不会被图层边界剪裁掉。一个CAShapeLayer可以在边界之外绘制。你的图层路径不会像在使用Core Graphics的普通CALayer一样被剪裁掉。</li><li>不会出现像素化。当你给CAShapeLayer做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化。</li></ul><h5 id="CASharpLayer-的属性"><a href="#CASharpLayer-的属性" class="headerlink" title="CASharpLayer 的属性"></a>CASharpLayer 的属性</h5><p>凡是标记<code>Animatable</code>都是可动画属性,可以再CoreAnimation使用来实现动画.</p><h6 id="path-Animatable"><a href="#path-Animatable" class="headerlink" title="path Animatable"></a>path <code>Animatable</code></h6><p> sharpLayer的路径,指定路径就能生成相应形状的sharpLayer</p><h6 id="fillColor-Animatable"><a href="#fillColor-Animatable" class="headerlink" title="fillColor; Animatable"></a>fillColor; <code>Animatable</code></h6><p> 填充色,默认是不透明的黑色</p><h6 id="fillRule"><a href="#fillRule" class="headerlink" title="fillRule"></a>fillRule</h6><p>填充规则,有<code>kCAFillRuleNonZero</code>(默认),<code>kCAFillRuleEvenOdd</code></p><h6 id="strokeColor-Animatable"><a href="#strokeColor-Animatable" class="headerlink" title="strokeColor Animatable"></a>strokeColor <code>Animatable</code></h6><p> 描边颜色</p><h6 id="strokeStart-Animatable"><a href="#strokeStart-Animatable" class="headerlink" title="strokeStart; Animatable"></a>strokeStart; <code>Animatable</code></h6><p>表示绘画开始的地方占总绘画过程的百分比,取值范围[0~1]</p><h6 id="strokeEnd-Animatable"><a href="#strokeEnd-Animatable" class="headerlink" title="strokeEnd; Animatable"></a>strokeEnd; <code>Animatable</code></h6><p>表示绘画结束的地方占总绘画过程的百分比,[0~1]</p><p>下面是通过改变path来实现路径的动画效果.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    UIImage *image = [UIImage imageNamed:@<span class="string">"image"</span>];</span><br><span class="line">    </span><br><span class="line">    CALayer *waterLayer = [CALayer layer];</span><br><span class="line">    waterLayer.bounds = CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">    waterLayer.anchorPoint = CGPointMake(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    waterLayer.position = CGPointMake(<span class="number">50</span>, <span class="number">200</span>);</span><br><span class="line">    waterLayer.contents = (__bridge id)image.CGImage;</span><br><span class="line">    [self.view.layer addSublayer:waterLayer];</span><br><span class="line">    </span><br><span class="line">    UIBezierPath *bezierPath = [UIBezierPath bezierPath];</span><br><span class="line">    [bezierPath moveToPoint:CGPointMake(<span class="number">0</span>, <span class="number">25</span>)];</span><br><span class="line">    [bezierPath addQuadCurveToPoint:CGPointMake(<span class="number">300</span>, <span class="number">25</span>) controlPoint:CGPointMake(<span class="number">150</span>, <span class="number">-30</span>)];</span><br><span class="line">    [bezierPath addLineToPoint:CGPointMake(<span class="number">300</span>, <span class="number">200</span>)];</span><br><span class="line">    [bezierPath addLineToPoint:CGPointMake(<span class="number">0</span>, <span class="number">200</span>)];</span><br><span class="line">    [bezierPath closePath];</span><br><span class="line">    </span><br><span class="line">    UIBezierPath *bezierPath2 = [UIBezierPath bezierPath];</span><br><span class="line">    [bezierPath2 moveToPoint:CGPointMake(<span class="number">0</span>, <span class="number">50</span>)];</span><br><span class="line">    [bezierPath2 addQuadCurveToPoint:CGPointMake(<span class="number">300</span>, <span class="number">50</span>) controlPoint:CGPointMake(<span class="number">150</span>, <span class="number">80</span>)];</span><br><span class="line">    [bezierPath2 addLineToPoint:CGPointMake(<span class="number">300</span>, <span class="number">200</span>)];</span><br><span class="line">    [bezierPath2 addLineToPoint:CGPointMake(<span class="number">0</span>, <span class="number">200</span>)];</span><br><span class="line">    [bezierPath2 closePath];</span><br><span class="line">    </span><br><span class="line">    _layer = [CAShapeLayer layer];</span><br><span class="line">    _layer.path = bezierPath.CGPath;</span><br><span class="line">    </span><br><span class="line">    waterLayer.mask = _layer;</span><br><span class="line">    </span><br><span class="line">    NSTimer *timer = [NSTimer timerWithTimeInterval:<span class="number">3</span> repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">        NSValue *toValue;</span><br><span class="line">        <span class="keyword">if</span> (_path1) &#123;</span><br><span class="line">            _path1 = NO;</span><br><span class="line">            toValue = (__bridge NSValue *)bezierPath.CGPath;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            _path1 = YES;</span><br><span class="line">            toValue = (__bridge NSValue *)bezierPath2.CGPath;</span><br><span class="line">        &#125;</span><br><span class="line">        CABasicAnimation *animation = [CABasicAnimation animation];</span><br><span class="line">        animation.duration = <span class="number">3</span>;</span><br><span class="line">        animation.removedOnCompletion = NO;</span><br><span class="line">        animation.fillMode = kCAFillModeForwards;</span><br><span class="line">        animation.keyPath = @<span class="string">"path"</span>;</span><br><span class="line">        animation.toValue = toValue;</span><br><span class="line">        [_layer addAnimation:animation forKey:nil];</span><br><span class="line">    &#125;];</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br><span class="line">    [timer fire];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://o7vzr7y09.bkt.clouddn.com/waterAnimation.gif" alt></p><h4 id="矢量图和bitmap"><a href="#矢量图和bitmap" class="headerlink" title="矢量图和bitmap"></a>矢量图和bitmap</h4><h5 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h5><p>位图是通过排列像素点来构造的，像素点的信息包括颜色+透明度(ARGB)，颜色通过RGB来表示，所以一个像素一共有4个信息(透明度、R、G、B)，每个信息的取值范围是0-255，也就是一共256个数，刚好可以用8位二进制来表示，所以每个像素点的信息通常通过32位（4字节）编码来表示，这种位图叫做32位位图，而一些位图没有Alpha通道，这样的位图每个像素点只有RGB信息，只需要24位就可以表示一个像素点的信息。</p><p>位图在进行变形（缩放、3D旋转等）时会重新绘制每个像素点的信息，所以会造成图形的模糊。</p><p>值得一提的是，对于GPU而言，它绘制位图的效率是相当高的，所以如果你要提高绘制效率，可以想办法把复杂的绘制内容转换成位图数据，然后丢给GPU进行渲染，比如使用CoreText来绘制文字。</p><h5 id="矢量图"><a href="#矢量图" class="headerlink" title="矢量图"></a>矢量图</h5><p>矢量图是通过对多个点进行布局然后按照一定规则进行连线后形成的图形。矢量图的信息总共只有两个：点属性和线属性。点属性包括点的坐标、连线顺序等；线属性包括线宽、描线颜色等。</p><p>每当矢量图进行变形的时候，只会把所有的点进行重新布局，然后重新按点属性和线属性进行连线。  <strong>所以每次变形都不会影响线宽，也不会让图变得模糊</strong>。</p><p>如何重新布局是通过把所有点坐标转换成矩阵信息，然后通过矩阵乘法重新计算新的矩阵，再把矩阵转换回点信息。比如要对一个矢量图进行旋转，就先把这个矢量图所有的点转换成一个矩阵（x,y,0），然后乘以旋转矩阵：</p><pre><code>(    cosa  sina   0     -sina  cosa  00      0  1)</code></pre><p>得到新的矩阵（x·cosa-y·sina, x·sina+y·cosa, 0）<br>然后把这个矩阵转换成点坐标（x·cosa-y·sina, x·sina+y·cosa）这就是新的点了。对矢量图所有的点进行这样的操作后，然后重新连线，出现的新的图形就是旋转后的矢量图了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CoreAnimation-CALayer-三&quot;&gt;&lt;a href=&quot;#CoreAnimation-CALayer-三&quot; class=&quot;headerlink&quot; title=&quot;CoreAnimation-CALayer(三)&quot;&gt;&lt;/a&gt;CoreAnimation-CA
      
    
    </summary>
    
      <category term="iOSTips" scheme="http://yincongxiao.top/categories/iOSTips/"/>
    
    
  </entry>
  
  <entry>
    <title>CoreAnimation-CALayer(二)</title>
    <link href="http://yincongxiao.top/2016/01/10/CoreAnimation-CALayer-%E4%BA%8C/"/>
    <id>http://yincongxiao.top/2016/01/10/CoreAnimation-CALayer-二/</id>
    <published>2016-01-10T09:33:11.000Z</published>
    <updated>2019-05-16T11:52:21.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CoreAnimation-CALayer-二"><a href="#CoreAnimation-CALayer-二" class="headerlink" title="CoreAnimation-CALayer(二)"></a>CoreAnimation-CALayer(二)</h2><h4 id="修改view默认的layer"><a href="#修改view默认的layer" class="headerlink" title="修改view默认的layer"></a>修改view默认的layer</h4><p>iOS中默认情况下UIView会创建一个layer,我们还可以为view指定其他的layer对象,大部分场景下我们不需要这样做,但是系统为我们提供了很多好用的layer子类,我们可以把这些layer指定为view相关的layer.比如<code>CATiledLayer</code>可以高效的管理大图片.<br>在view中重写<code>layerClass</code>方法来为view指定layer,再比如我们的view使用OpenGL ES 技术来进行绘制,我们可能会把view的layer换成<code>CAMetalLayer</code>或者<code>CAEAGLLayer</code><br>替换很简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CustomView.m</span><br><span class="line">+ (Class) layerClass &#123;</span><br><span class="line"><span class="keyword">return</span> [CAMetalLayer class];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mask"><a href="#mask" class="headerlink" title="mask"></a>mask</h4><p><code>mask</code>遮盖层.本身也是一个layer</p><p>maskLayer类似于一个子图层，相对于父图层（即拥有该属性的图层，在这里就是layer）布局，但是它却不是一个普通的子图层。maskLayer并不会直接绘制在父图层之上，它只是定义了父图层的“可视部分”(可视形状)。mask属性就像是一个饼干切割机，mask图层实心的部分会被保留下来，其他的（透明的部分）则会被抛弃。如图<br><img src="http://img.blog.csdn.net/20160812091842446" alt><br>通常我们使用<code>CASarpLayer</code>进行自定义的形状,然后设置为layer的mask,这样我们就可以得到任意形状的图片</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    UIImage *image = [UIImage imageNamed:@<span class="string">"image"</span>];</span><br><span class="line">_layer = [CALayer layer];</span><br><span class="line">    _layer.anchorPoint = CGPointMake(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    _layer.bounds = CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">    _layer.position = CGPointMake(<span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line">    _layer.contents = (__bridge id)image.CGImage;</span><br><span class="line">    _layer.masksToBounds = YES;</span><br><span class="line">    _layer.contentsGravity = kCAGravityResizeAspectFill;</span><br><span class="line">    [self.view.layer addSublayer:_layer];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="http://o7vzr7y09.bkt.clouddn.com/Simulator%20Screen%20Shot%202017%E5%B9%B45%E6%9C%883%E6%97%A5%20%E4%B8%8B%E5%8D%884.56.44.png" alt><br>我们添加下面的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    UIImage *image = [UIImage imageNamed:@<span class="string">"image"</span>];</span><br><span class="line">    _layer = [CALayer layer];</span><br><span class="line">    _layer.anchorPoint = CGPointMake(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    _layer.bounds = CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">    _layer.position = CGPointMake(<span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line">    _layer.contents = (__bridge id)image.CGImage;</span><br><span class="line">    _layer.masksToBounds = YES;</span><br><span class="line">    _layer.contentsGravity = kCAGravityResizeAspectFill;</span><br><span class="line">    [self.view.layer addSublayer:_layer];</span><br><span class="line">    </span><br><span class="line">    CAShapeLayer *sharpLayer = [CAShapeLayer layer];</span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPath];</span><br><span class="line">    <span class="comment">//这里我制定了一个圆形,可以随意指定想要的图形.</span></span><br><span class="line">    [path addArcWithCenter:CGPointMake(<span class="number">100</span>, <span class="number">100</span>) radius:<span class="number">100</span> startAngle:<span class="number">0</span> endAngle:M_PI * <span class="number">2</span> clockwise:YES];</span><br><span class="line">    sharpLayer.path = path.CGPath;</span><br><span class="line">    _layer.mask = sharpLayer;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://o7vzr7y09.bkt.clouddn.com/Simulator%20Screen%20Shot%202017%E5%B9%B45%E6%9C%883%E6%97%A5%20%E4%B8%8B%E5%8D%884.58.11.png" alt><br>下面我们再来添加几行代码来实现一个圆环,具体看注释</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sharpLayer.lineWidth = <span class="number">30</span>;</span><br><span class="line">   <span class="comment">//指定描边颜色,随意设置不为clear的颜色就好,不设置的话不能达到效果!</span></span><br><span class="line">   sharpLayer.strokeColor = [UIColor redColor].CGColor;</span><br><span class="line">   <span class="comment">//填充颜色设置为clear中间部分就不会显示出来</span></span><br><span class="line">   sharpLayer.fillColor = [UIColor clearColor].CGColor;</span><br></pre></td></tr></table></figure><p><img src="http://o7vzr7y09.bkt.clouddn.com/Simulator%20Screen%20Shot%202017%E5%B9%B45%E6%9C%883%E6%97%A5%20%E4%B8%8B%E5%8D%885.11.33.png" alt><br>因为mask本身是个layer,所以它可以拥有动画效果<br>我们把代码稍作修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    UIImage *image = [UIImage imageNamed:@<span class="string">"image"</span>];</span><br><span class="line">    </span><br><span class="line">    _layer = [CALayer layer];</span><br><span class="line">    _layer.anchorPoint = CGPointMake(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    _layer.bounds = CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">    _layer.position = CGPointMake(<span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line">    _layer.contents = (__bridge id)image.CGImage;</span><br><span class="line">    _layer.masksToBounds = YES;</span><br><span class="line">    _layer.contentsGravity = kCAGravityResizeAspectFill;</span><br><span class="line">    [self.view.layer addSublayer:_layer];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    CAShapeLayer *sharpLayer = [CAShapeLayer layer];</span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPath];</span><br><span class="line">    [path addArcWithCenter:CGPointMake(<span class="number">100</span>, <span class="number">100</span>) radius:<span class="number">100</span> <span class="number">-15</span> startAngle:<span class="number">0</span> endAngle:M_PI * <span class="number">2</span> clockwise:YES];</span><br><span class="line">    sharpLayer.path = path.CGPath;</span><br><span class="line">    _layer.mask = sharpLayer;</span><br><span class="line">    </span><br><span class="line">    sharpLayer.lineWidth = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//指定描边颜色,随意设置不为clear的颜色就好,不设置的话不能达到效果!</span></span><br><span class="line">    sharpLayer.strokeColor = [UIColor redColor].CGColor;</span><br><span class="line">    <span class="comment">//填充颜色设置为clear中间部分就不会显示出来</span></span><br><span class="line">    sharpLayer.fillColor = [UIColor clearColor].CGColor;</span><br><span class="line"></span><br><span class="line">    CABasicAnimation *animation = [CABasicAnimation animation];</span><br><span class="line">    animation.keyPath = @<span class="string">"strokeEnd"</span>;</span><br><span class="line">    animation.fromValue = @<span class="number">0</span>;</span><br><span class="line">    animation.duration = <span class="number">3</span>;</span><br><span class="line">    [sharpLayer addAnimation:animation forKey:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://o7vzr7y09.bkt.clouddn.com/caca.gif" alt></p><h4 id="CALayer-和-UIView的关系"><a href="#CALayer-和-UIView的关系" class="headerlink" title="CALayer 和  UIView的关系"></a>CALayer 和  UIView的关系</h4><p><code>CALayer</code>作为一个跨平台框架（OS X和iOS）<code>QuatzCore</code>的类，负责MAC和iPhone（ipad等设备）上绘制所有的显示内容。而iOS系统为了处理用户交互事件（触屏操作）用UIView封装了一次CALayer，UIView本身负责处理交互事件，其持有一个Layer，用来负责绘制这个View的内容。而我们对UIView的和绘制相关的属性赋值和访问的时候（frame、backgroundColor等）UIView实际上是直接调用其Layer对应的属性（frame对应frame，center对应position等）的getter和setter。</p><p>layers并不是view的替代品,也就是说如果只使用CALayer是无法满足所有的界面要求的,layer与view协同合作,尤其是实现高效的动画或者渲染效果上面,但是layer不能识别用户交互事件,进行实际的绘制工作,不能参与事件传递链条,所以在app中必须要有部分view来接受用户的交互事件</p><p>在iOS中每一个View都有一个与之对应的layer.但是在OSX中我们必须指定view是否可以有自己的layer,在OSX v10.8以后的版本可以向iOS一样为每个view添加默认的layer,但是这并不是必须的,仍然可以在没必要使用view的时候来使用layer进行替换,layer在某种程度上会造成内存的增加,所以在使用之前最好做好利弊的权衡来决定是否使用这项技术.</p><blockquote><p>这篇文章主要讨论了layer的mask层,知道了mask层我们就可以实现任意形状的自定义图层!<br>明白了UIView 和 CALayer的关系,我们就可以在适当的场景选择不同的技术进行实现.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CoreAnimation-CALayer-二&quot;&gt;&lt;a href=&quot;#CoreAnimation-CALayer-二&quot; class=&quot;headerlink&quot; title=&quot;CoreAnimation-CALayer(二)&quot;&gt;&lt;/a&gt;CoreAnimation-CA
      
    
    </summary>
    
      <category term="iOSTips" scheme="http://yincongxiao.top/categories/iOSTips/"/>
    
    
  </entry>
  
  <entry>
    <title>CoreAnimation-CALayer(一)</title>
    <link href="http://yincongxiao.top/2016/01/03/CoreAnimation-CALayer-%E4%B8%80/"/>
    <id>http://yincongxiao.top/2016/01/03/CoreAnimation-CALayer-一/</id>
    <published>2016-01-02T16:55:20.000Z</published>
    <updated>2019-05-16T11:52:21.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CoreAnimation-CALayer-一"><a href="#CoreAnimation-CALayer-一" class="headerlink" title="CoreAnimation-CALayer(一)"></a>CoreAnimation-CALayer(一)</h2><h3 id="初识CoreAnimation"><a href="#初识CoreAnimation" class="headerlink" title="初识CoreAnimation"></a>初识CoreAnimation</h3><p>我们一般知道<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/CoreAnimationBasics/CoreAnimationBasics.html#//apple_ref/doc/uid/TP40004514-CH2-SW3" target="_blank" rel="noopener">CoreAnimation</a>是一种非常强大动画技术,其实CoreAnimation还是iOS和OSX中图形渲染的核心,我们在进行图形界面开发的时候无时无刻不是在使用它,使用CoreAnimation我们只需要进行简单的配置,系统就会帮我们进行每一帧的绘制从而达到流畅绚丽的动画效果.<br><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/Art/ca_architecture_2x.png" alt><br>上面是官方文档给出的iOS图形渲染结构图</p><ul><li>Craphics Hardware : GPU等负责渲染的硬件,操作系统封装了硬件层,提供了统一的绘制接口,这里会有一系列的针对不同硬件的封装接口.</li><li>OpenGL ES 层统一封装了绘图硬件的接口,我们使用OpenGL的统一接口就可以控制任意的绘图硬件了,但是它是C语言实现的</li><li>CoreAnimation 为了更友好的使用OpenGL引擎,在iOS/OSX中苹果针对OpenGL进行了封装,这就是CoreAnimation</li></ul><p>上面是对iOS绘图系统做了一个简单的介绍,下面我们进行深入的学习<br>预计的CoreAnimation的系列文章包括:</p><ul><li>CALayer</li><li>CoreAnimation类的结构</li><li>运用CoreAnimation进行动画</li></ul><h3 id="CALayer"><a href="#CALayer" class="headerlink" title="CALayer"></a>CALayer</h3><p>CoreAnimation本身是作用在layer上面并不是UIView上,所以我们有必要首先介绍一下CALayer.<br> <code>CALayer</code>是什么?<br>  CALayer用来绘制我们能看到的一切!官网介绍: <code>Layers Provide the Basis for Drawing and Animations</code>（Layers是3D空间中的2维平面,是我们使用CoreAnimation进行绘图的核心,layer管理着视图的位置,内容,和其他可视化的属性,通过<code>bitmap</code>来管理这些信息,bitmap本身可以是视图绘制的结果也可以是你指定的镜像.基于这个原因,calayer可以看做是app中的model层,因为它就是来<strong>管理绘图信息</strong>的,明白这一点对理解以后的动画操作帮助很大.<br>  layer本身并不做实际的绘制工作,它只是收集app提供的内容,并且将这些内容缓存到bitmap中,当我们改变layer的属性时仅仅是改变了与layer相关的状态信息,如果这个属性是animateable的那么CoreAnimation系统会在合适的时机将layer的bitmap以及状态信息提交到硬件绘制系统(GPU).<br><img src="http://img.blog.csdn.net/20150110094646249?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGVsbG9fSHdj/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt><br>之所以layer有一个与之相关的静态bitmap,所以基于layer的动画不同于基于view的动画,通过改变UIView的动画属性往往需要重复触发<code>- drawRect:</code>方法进行重绘,这个方法是比较昂贵的,因为它使用<code>CUP</code>计算,并且发生在主线程中!<br>如果使用coreAnimation,我们虽然进行大量的animated属性的改变,这些改变只会将layer的bitmap状态变化,当下一次屏幕刷新的时候才将bitmap中储存的最新的信息提交到CPU中,储存的过程是后台线程进行的.</p><h4 id="CALayer的基本使用"><a href="#CALayer的基本使用" class="headerlink" title="CALayer的基本使用"></a>CALayer的基本使用</h4><h4 id="常见属性"><a href="#常见属性" class="headerlink" title="常见属性"></a>常见属性</h4><h5 id="animatable-属性"><a href="#animatable-属性" class="headerlink" title="animatable 属性"></a>animatable 属性</h5><p>我们点进<code>CALayer</code>可以看到很多属性的注释后面都有一个<code>animatable</code>标示,这个标示代表修改这个属性附带有动画效果.具体一下两个特征</p><ul><li>直接修改非<code>rootLayer</code> 的可动画属性可以实现隐式动画</li><li>在CoreAnimation中作为keyPath来进行修改产生动画效果.</li></ul><p>利用CALayer我们可以实现一些常见的显示效果,例如阴影,圆角,背景颜色等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ViewController.m</span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    CALayer *redLayer = [CALayer layer];</span><br><span class="line">    redLayer.frame = CGRectMake(<span class="number">10</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    redLayer.backgroundColor= [UIColor redColor].CGColor;</span><br><span class="line">    redLayer.cornerRadius = <span class="number">20.0</span>;<span class="comment">//圆角</span></span><br><span class="line">    redLayer.shadowColor = [UIColor blackColor].CGColor;<span class="comment">//阴影颜色</span></span><br><span class="line">    redLayer.shadowOpacity = <span class="number">0.5</span>;<span class="comment">//阴影透明度</span></span><br><span class="line">    redLayer.shadowOffset = CGSizeMake(<span class="number">3.0</span>, <span class="number">3.0</span>);<span class="comment">//阴影的偏移量</span></span><br><span class="line">    redLayer.borderColor = [UIColor whiteColor].CGColor;<span class="comment">//边界颜色</span></span><br><span class="line">    redLayer.borderWidth = <span class="number">2</span>;<span class="comment">//边界宽度</span></span><br><span class="line">    [self.view.layer addSublayer:redLayer];<span class="comment">//将layer添加到view的layer图层上.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://o7vzr7y09.bkt.clouddn.com/Simulator%20Screen%20Shot%202017%E5%B9%B44%E6%9C%8828%E6%97%A5%20%E4%B8%8B%E5%8D%883.24.20.png" alt></p><h5 id="layer的内容"><a href="#layer的内容" class="headerlink" title="layer的内容"></a>layer的内容</h5><p>layers 管理着app提供的显示内容,所有要展示的可视图形数据(成为内容contents)共同构成了layer的<code>bitmap</code>.<br>如果你手动初始化layer,你可以通过以下三种方式为bitmap提供内容content</p><ul><li>将image对象赋值给<code>layer.contents</code>属性(适用于layer的内容很少或者从来不会改变的)</li><li>给layer设置一个代理<code>(id&lt;CALayerDelegate&gt;)</code>对象,用代理对象来进行绘制内容,适用于layer的内容可能周期发生变化或者需要使用另一个对象进行绘制工作的模式.(UIView就是这种模式.)</li><li>定义CALayer的子类,重写绘制相关的方法从而为layer提供内容</li></ul><h6 id="设置contents"><a href="#设置contents" class="headerlink" title="设置contents"></a>设置contents</h6><p><strong><em>contents</em></strong>代表了layer呈现的内容对象,是一个id类型,但是我们需要将OC对象转换成<code>CoreGraphics</code>类型的值在设置才有效果.例如我们可以通过设置layer的<code>contents</code>属性来代替UIImageView来呈现图片.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_bview = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];</span><br><span class="line">//直接设置image给contents是不行的</span><br><span class="line">   _bview.layer.contents = (__bridge id)image.CGImage;</span><br><span class="line">   _bview.layer.contentsGravity = kCAGravityResizeAspectFill;</span><br><span class="line">   [self.view addSubview:_bview];</span><br></pre></td></tr></table></figure><p><img src="http://o7vzr7y09.bkt.clouddn.com/Simulator%20Screen%20Shot%202017%E5%B9%B45%E6%9C%882%E6%97%A5%20%E4%B8%8B%E5%8D%885.59.21.png" alt></p><h6 id="设置delegate"><a href="#设置delegate" class="headerlink" title="设置delegate"></a>设置delegate</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)displayLayer:(CALayer *)layer &#123;</span><br><span class="line">    <span class="comment">//在这个方法里面可以通过特定的条件变量或者提供第三方的类给layer设置内容</span></span><br><span class="line">    <span class="keyword">if</span> (self.displayYesImage) &#123;</span><br><span class="line">        <span class="comment">// Display the Yes image</span></span><br><span class="line">        theLayer.contents = [someHelperObject loadStateYesImage];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Display the No image</span></span><br><span class="line">        theLayer.contents = [someHelperObject loadStateNoImage];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果上面的方法没有给layer设置内容,就会来到这个方法,在这个方法里面直接在ctx上下文中进行绘制工作</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx &#123;</span><br><span class="line">    CGMutablePathRef thePath = CGPathCreateMutable();</span><br><span class="line">    </span><br><span class="line">    CGPathMoveToPoint(thePath,<span class="literal">NULL</span>,<span class="number">15.0f</span>,<span class="number">15.f</span>);</span><br><span class="line">    CGPathAddCurveToPoint(thePath,</span><br><span class="line">                          <span class="literal">NULL</span>,</span><br><span class="line">                          <span class="number">15.f</span>,<span class="number">250.0f</span>,</span><br><span class="line">                          <span class="number">295.0f</span>,<span class="number">250.0f</span>,</span><br><span class="line">                          <span class="number">295.0f</span>,<span class="number">15.0f</span>);</span><br><span class="line">    </span><br><span class="line">    CGContextBeginPath(theContext);</span><br><span class="line">    CGContextAddPath(theContext, thePath);</span><br><span class="line">    </span><br><span class="line">    CGContextSetLineWidth(theContext, <span class="number">5</span>);</span><br><span class="line">    CGContextStrokePath(theContext);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Release the path</span></span><br><span class="line">    CFRelease(thePath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="子类化layer"><a href="#子类化layer" class="headerlink" title="子类化layer"></a>子类化layer</h6><p>如果我们自定义了layer那么可以通过复写绘制方法进行绘制,通常我们不会这样做.但是这样layer的内容就是自己决定,例如<code>CATileLayer</code>类管理着一张图片,它可以将图片分割成若干小的部分,从而进行分开展示,因为只有layer知道那个碎片在特定的时间是否该展示,重写的步骤</p><ul><li>重写 <code>display</code>方法直接给layer设置contents</li><li>重写<code>drawInContext:</code>根据上下文进行绘制.</li></ul><p>选择具体重写哪个方法要看你想怎样控制绘制任务,重写<code>display</code>方法意味着你要 自己负责创建<code>CGImageRef</code>并且设置给contents属性,如果你仅仅是绘制的话那么应该重写<code>drawInContext:</code>.        </p><h5 id="contentsGravity"><a href="#contentsGravity" class="headerlink" title="contentsGravity"></a>contentsGravity</h5><p><code>contentsGravity</code>是content在layer上的呈现方式,修改UIView的<code>contentMode</code>属性其实就是在操作<code>contentsGravity</code><br>对应的枚举值为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CA_EXTERN NSString * const kCAGravityCenter</span><br><span class="line">CA_EXTERN NSString * const kCAGravityTop</span><br><span class="line">CA_EXTERN NSString * const kCAGravityBottom</span><br><span class="line">CA_EXTERN NSString * const kCAGravityLeft</span><br><span class="line">CA_EXTERN NSString * const kCAGravityRight</span><br><span class="line">CA_EXTERN NSString * const kCAGravityTopLeft</span><br><span class="line">CA_EXTERN NSString * const kCAGravityTopRight</span><br><span class="line">CA_EXTERN NSString * const kCAGravityBottomLeft</span><br><span class="line">CA_EXTERN NSString * const kCAGravityBottomRight</span><br><span class="line">CA_EXTERN NSString * const kCAGravityResize</span><br><span class="line">CA_EXTERN NSString * const kCAGravityResizeAspect -&gt; `UIViewContentModeScaleAspectFit`</span><br><span class="line">CA_EXTERN NSString * const kCAGravityResizeAspectFill -&gt; `UIViewContentModeScaleAspectFill`</span><br></pre></td></tr></table></figure><h6 id="subLayers"><a href="#subLayers" class="headerlink" title="subLayers"></a>subLayers</h6><p>CALayer 支持添加子layer,并且支持调整子layer的层级顺序,对应的api是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addSublayer:(CALayer *)layer;</span><br><span class="line">- (<span class="keyword">void</span>)insertSublayer:(CALayer *)layer atIndex:(<span class="keyword">unsigned</span>)idx;</span><br><span class="line">- (<span class="keyword">void</span>)insertSublayer:(CALayer *)layer below:(nullable CALayer *)sibling;</span><br><span class="line">- (<span class="keyword">void</span>)insertSublayer:(CALayer *)layer above:(nullable CALayer *)sibling;</span><br><span class="line">- (<span class="keyword">void</span>)replaceSublayer:(CALayer *)layer with:(CALayer *)layer2;</span><br></pre></td></tr></table></figure><p>CALayer 的子类<br><img src="http://o7vzr7y09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-28%20%E4%B8%8B%E5%8D%883.29.51.png" alt><br>那么他们是做什么的呢,后面我们可能会用到其中的一个或几个来实现特殊的显示效果.</p><table><thead><tr><th>CAEmitterLayer</th><th>发散层，可以实现粒子效果</th></tr></thead><tbody><tr><td>CAGradientLayer</td><td>梯度层，颜色渐变</td></tr><tr><td>CAEAGLayer</td><td>用OpenGL ES绘制的层</td></tr><tr><td>CAReplicationLayer</td><td>拷贝层可以用来复制sublayer</td></tr><tr><td>CAScrollLayer</td><td>可滑动的层</td></tr><tr><td>CAShapeLayer</td><td>绘制立体的贝塞尔曲线</td></tr><tr><td>CATextLayer</td><td>可以绘制AttributeString</td></tr><tr><td>CATiledLayer</td><td>用来管理一副可以被分割的大图</td></tr><tr><td>CATransformLayer</td><td>用来渲染3D layer的层次结构</td></tr></tbody></table><h6 id="frame-position-anchorPoint-bounds"><a href="#frame-position-anchorPoint-bounds" class="headerlink" title="frame,position,anchorPoint,bounds"></a>frame,position,anchorPoint,bounds</h6><p>frame 和 bounds<br>frame,bounds在一开始学习UI的时候就接触了这两个概念,但是可能很多人只知道frame是相对父视图坐标系统(0, 0)点的偏移量(这里不考虑size),bounds是相对于自身坐标系的(0, 0)点位置<br><img src="http://img.my.csdn.net/uploads/201303/24/1364058232_8785.jpg" alt><br>修改frame的origin会产生位移,那么是否知道修改bounds会带来什么影响呢?其实坐标系统的关键就是要知道它的<strong>原点</strong>(0, 0)点在什么位置.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UIView *redView = [[UIView alloc] initWithFrame:CGRectMake(<span class="number">20</span>, <span class="number">20</span>, <span class="number">200</span>, <span class="number">200</span>)];</span><br><span class="line">   redView.backgroundColor = [UIColor redColor];</span><br><span class="line">   redView.bounds = CGRectMake(- <span class="number">20</span>, - <span class="number">20</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">   [self.view addSubview:redView];</span><br><span class="line">   </span><br><span class="line">   UIView *subView = [[UIView alloc] initWithFrame:CGRectMake(<span class="number">20</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line">   subView.backgroundColor = [UIColor blueColor];</span><br><span class="line">   [redView addSubview:subView];</span><br></pre></td></tr></table></figure><p><img src="http://o7vzr7y09.bkt.clouddn.com/Simulator%20Screen%20Shot%202017%E5%B9%B45%E6%9C%883%E6%97%A5%20%E4%B8%8A%E5%8D%8812.33.02.png" alt><br>这里将redView的bounds设置为(- 20, - 20, 200, 200)以后那么redView左上角的位置就是(-20,-20),那么它的原点(0,0)就是相对于左上角(10, 10)的位置,所以subView会显示在距离redView左上角(40, 40)的位置.<br>所以设置bounds会影响子视图的位置.</p><p>position: 位置点, 定义了锚点(anchorPoint)相对父layer上的位置.<br>anchorPoint: 锚点,定义了layer上的哪个点在position上.x,y取值都为0~1之间的数,默认(0.5-0.5)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_layer = [CALayer layer];</span><br><span class="line">   _layer.frame = CGRectMake(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">   _layer.backgroundColor = [UIColor redColor].CGColor;</span><br><span class="line">   [self.view.layer addSublayer:_layer];</span><br><span class="line">   NSLog(@<span class="string">"%@"</span>,_layer);</span><br><span class="line">   <span class="comment">//position = CGPoint (60 60)</span></span><br><span class="line">   <span class="comment">//bounds = CGRect (0 0; 100 100)</span></span><br><span class="line">   <span class="comment">//anchorPoint = CGPoint (0.5, 0.5)</span></span><br></pre></td></tr></table></figure><p>下面贴两张官方的图,下图展示了虽然位置是相同的,但是因为<code>anchorPoint</code>不同导致的position的不同<br><img src="http://img.blog.csdn.net/20150110130534295?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGVsbG9fSHdj/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt>  <img src="http://img.blog.csdn.net/20150110130534295?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGVsbG9fSHdj/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt><br>注意思考为什么下面只是代码添加的顺序不同就会产生不同的效果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_layer = [CALayer layer];</span><br><span class="line">   _layer.anchorPoint = CGPointMake(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   _layer.frame = CGRectMake(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">   _layer.backgroundColor = [UIColor redColor].CGColor;</span><br><span class="line">   [self.view.layer addSublayer:_layer];</span><br></pre></td></tr></table></figure><p><img src="http://o7vzr7y09.bkt.clouddn.com/Simulator%20Screen%20Shot%202017%E5%B9%B45%E6%9C%883%E6%97%A5%20%E4%B8%8A%E5%8D%8812.48.55.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_layer = [CALayer layer];</span><br><span class="line">   _layer.frame = CGRectMake(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">   _layer.anchorPoint = CGPointMake(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   _layer.backgroundColor = [UIColor redColor].CGColor;</span><br><span class="line">   [self.view.layer addSublayer:_layer];</span><br></pre></td></tr></table></figure><p><img src="http://o7vzr7y09.bkt.clouddn.com/sss.png" alt></p><h6 id="zPosition"><a href="#zPosition" class="headerlink" title="zPosition"></a>zPosition</h6><p>在Z轴(垂直于屏幕坐标轴)上的值.默认是0,所以我们通过设置zPosition来调整子layer的显示,晚添加的layer也可能位于早添加的layer的下面</p><h6 id="presentationLayer-和-modelLayer"><a href="#presentationLayer-和-modelLayer" class="headerlink" title="presentationLayer 和 modelLayer"></a>presentationLayer 和 modelLayer</h6><p>在CALayer内部，它控制着两个属性：presentationLayer(以下称为P)和modelLayer（以下称为M）。P只负责显示，M只负责数据的存储和获取。我们对layer的各种属性赋值比如frame，实际上是直接对M的属性赋值，而P将在每一次屏幕刷新的时候回到M的状态。比如此时M的状态是1，P的状态也是1，然后我们把M的状态改为2，那么此时P还没有过去，也就是我们看到的状态P还是1，在下一次屏幕刷新的时候P才变为2。而我们几乎感知不到两次屏幕刷新之间的间隙，所以感觉就是我们一对M赋值，P就过去了.强烈建议看<a href="http://blog.csdn.net/u013282174/article/details/50388546" target="_blank" rel="noopener">这篇博文</a>来深入了解这两个属性.</p><h5 id="CALayer-的隐式动画"><a href="#CALayer-的隐式动画" class="headerlink" title="CALayer 的隐式动画"></a>CALayer 的隐式动画</h5><p>任何<code>UIView</code>内部都有一个<code>CALayer</code>来进行渲染,这个layer就称为<code>UIView</code>的<code>根层</code>(rootLayer),在iOS中修改<strong>非根层</strong>(不是view.layer)的<code>Animatable</code>类型的属性时会产生动画,称之为<code>隐式动画</code>.<br>修改position的隐式动画</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    _layer = [CALayer layer];</span><br><span class="line">    _layer.anchorPoint = CGPointMake(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    _layer.frame = CGRectMake(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    _layer.backgroundColor = [UIColor redColor].CGColor;</span><br><span class="line">    [self.view.layer addSublayer:_layer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    _layer.position = CGPointMake(<span class="number">50</span>, <span class="number">70</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://o7vzr7y09.bkt.clouddn.com/animation1.gif" alt><br>修改anchorPoint的隐式动画,跟上图一样的效果,原理是position没有变但是anchorPoint变了那么如果仍要保持原来的positon的话,layer就会向右下平移.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">_layer.delegate = self;</span><br><span class="line">    _layer.bounds = CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    _layer.position = CGPointMake(<span class="number">60</span>, <span class="number">60</span>);</span><br><span class="line">    _layer.backgroundColor = [UIColor redColor].CGColor;</span><br><span class="line">    [self.view.layer addSublayer:_layer];</span><br><span class="line">   &#125;</span><br><span class="line">   - (<span class="keyword">void</span>)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">   _layer.anchorPoint = CGPointMake(<span class="number">0</span>, <span class="number">0</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里改变position属性产生位移动画效果,还可以设置</p><p><code>backgroundColor</code>,<code>transform</code>,<code>anchorPoint</code>,<code>zPosition</code>,<code>anchorPointZ</code>,<code>frame</code>,<code>hidden</code>,<code>doubleSided</code>,<code>masksToBounds</code>,<code>contents</code>,<code>contentsRect</code>,<code>contentsScale</code>,<code>contentsCenter</code>,<code>minificationFilterBias</code>.如果想关闭隐式动画可以通过以下设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[CATransaction setDisableActions:YES];</span><br></pre></td></tr></table></figure></p><p>下篇会继续讲解CALayer的一些使用.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CoreAnimation-CALayer-一&quot;&gt;&lt;a href=&quot;#CoreAnimation-CALayer-一&quot; class=&quot;headerlink&quot; title=&quot;CoreAnimation-CALayer(一)&quot;&gt;&lt;/a&gt;CoreAnimation-CA
      
    
    </summary>
    
      <category term="iOSTips" scheme="http://yincongxiao.top/categories/iOSTips/"/>
    
    
      <category term="CoreAnimation" scheme="http://yincongxiao.top/tags/CoreAnimation/"/>
    
  </entry>
  
  <entry>
    <title>UIScrollView 的 delaysContentTouches</title>
    <link href="http://yincongxiao.top/2015/11/23/UIScrollView-%E7%9A%84-delaysContentTouches/"/>
    <id>http://yincongxiao.top/2015/11/23/UIScrollView-的-delaysContentTouches/</id>
    <published>2015-11-23T05:15:33.000Z</published>
    <updated>2019-05-16T11:52:21.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UIScrollView的delaysContentTouches"><a href="#UIScrollView的delaysContentTouches" class="headerlink" title="UIScrollView的delaysContentTouches"></a>UIScrollView的<code>delaysContentTouches</code></h1><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h4><ul><li>当UIScrollView上面有一个UIButton控件,在快速点击button的时候button没有高亮状态,却能响应点击事件,长按却有高亮,这样对用户很不友好</li><li>在iOS8下运行以前开发的项目时,如果触摸点是在子控件下，则会导致触摸事件被子控件接收后不能再次返回事件给UIScrollView，以至于不能滑动UIScrollView。</li></ul><p>查阅资料后发现:</p><blockquote><p>UIScrollView的 touch 工作原理: 当手指touch的时候，UIScrollView会拦截该 touch 事件,会等待一段时间(150ms)，在这段时间内，如果没有手指没有移动，当事件结束时，UIScrollView会发送tracking events到子视图上。在事件结束前，手指发生了移动，那么UIScrollView就会进行移动，从而不会向子视图发送事件.</p></blockquote><h5 id="delaysContentTouches"><a href="#delaysContentTouches" class="headerlink" title="delaysContentTouches"></a>delaysContentTouches</h5><p><code>default is YES. if NO, we immediately call -touchesShouldBegin:withEvent:inContentView:. this has no effect on presses</code></p><p><code>delaysContentTouches</code> 默认值为YES，即UIScrollView会在接受到手势是延迟150ms来判断该手势是否能触发UIScrollView的滑动事件；<br><code>delaysContentTouches</code> 为NO时，UIScrollView会立马将接受到的事件分发到子视图上</p><p>如果我们单纯地将这个属性设置为NO,那么当手指触摸点在子view上滑动scrollView时就不能正常滑动,应为事件直接被发送给了子view处理<br>我们还要做的是重写<code>- (BOOL)touchesShouldCancelInContentView:(UIView *)view</code>方法,这个方法的调用时机是:当手指在子view上开始滑动时系统会调用这个方法询问是否取消子view的touch事件,如果返回no,那么不取消,仍然由子view处理,如果返回yes那么子view取消touch事件交由scrollView接管</p><p>上面原理看完了那么我们需要做什么呢?</p><ol><li>自定义scrollView,将delaysContentTouches设置为NO</li><li>重写<code>touchesShouldCancelInContentView</code>判断如果子View是我们的button返回yes,否则返回super操作.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface CustomScrollView : UIScrollView</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation CustomScrollView</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame &#123;</span><br><span class="line">    if (self = [super initWithFrame:frame]) &#123;</span><br><span class="line">        self.delaysContentTouches = NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)touchesShouldCancelInContentView:(UIView *)view &#123;</span><br><span class="line">    if ([view isKindOfClass:[UIButton class]]) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">     return [super touchesShouldCancelInContentView:view];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="UITableView"><a href="#UITableView" class="headerlink" title="UITableView"></a>UITableView</h4><p><code>UITableView</code>是<code>UIScrollView</code>的子类,当然也会遇到上面的问题,如果我们仅仅只是按照上面的解决方法自定义tableView,你会发现快速点击button还是不会高亮,原因是<code>UITableView</code>和cell之间还会有其他我们看不到的view层,这些层的<code>delaysContentTouches</code>默认也是YES</p><p>在iOS7与iOS8的表现还不一样</p><ul><li>iOS7下一个UIScrollView会有若干个<code>UITableVieCellScrollVIew</code>,他们存在于cell的contentView之间</li><li>iOS8下一个UIScrollView在scrollView本身和cell之间会有一个<code>UITableViewWrapperView</code>,并没有iOS7下的<code>UITableVieCellScrollVIew</code>.</li></ul><p>我们要做的就是找到这些view,然后将它们的<code>delaysContentTouches</code>设置为NO.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@interface CustomTableView : UITableView</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation CustomTableView</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame &#123;</span><br><span class="line">    if (self = [super initWithFrame:frame]) &#123;</span><br><span class="line">        </span><br><span class="line">        self.delaysContentTouches = NO;</span><br><span class="line">        </span><br><span class="line">        ///iOS 7</span><br><span class="line">        for (UIView *subView in self.subviews) &#123;</span><br><span class="line">            if ([NSStringFromClass(subView.class) hasSuffix:@&quot;CellScrollView&quot;]) &#123;</span><br><span class="line">                UIScrollView *scrollView = (UIScrollView *)subView;</span><br><span class="line">                scrollView.delaysContentTouches = NO;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ///iOS 8</span><br><span class="line">        UIView *wrapView = self.subviews.firstObject;</span><br><span class="line">        if (wrapView &amp;&amp; [NSStringFromClass(wrapView.class) hasSuffix:@&quot;WrapperView&quot;]) &#123;</span><br><span class="line">            for (UIGestureRecognizer *gesture in wrapView.gestureRecognizers) &#123;</span><br><span class="line">                // UIScrollViewDelayedTouchesBeganGestureRecognizer</span><br><span class="line">                if ([NSStringFromClass(gesture.class) containsString:@&quot;DelayedTouchesBegan&quot;] ) &#123;</span><br><span class="line">                    gesture.enabled = NO;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)touchesShouldCancelInContentView:(UIView *)view &#123;</span><br><span class="line">    if ([view isKindOfClass:[UIButton class]]) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">     return [super touchesShouldCancelInContentView:view];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;UIScrollView的delaysContentTouches&quot;&gt;&lt;a href=&quot;#UIScrollView的delaysContentTouches&quot; class=&quot;headerlink&quot; title=&quot;UIScrollView的delaysContent
      
    
    </summary>
    
      <category term="iOSTips" scheme="http://yincongxiao.top/categories/iOSTips/"/>
    
    
  </entry>
  
  <entry>
    <title>reactivecocoa深入学习</title>
    <link href="http://yincongxiao.top/2015/11/15/reactivecocoa%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yincongxiao.top/2015/11/15/reactivecocoa深入学习/</id>
    <published>2015-11-15T12:13:55.000Z</published>
    <updated>2019-05-16T11:52:21.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ReactiveCocoa"><a href="#ReactiveCocoa" class="headerlink" title="ReactiveCocoa"></a>ReactiveCocoa</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>在 <strong>iOS</strong> 编程中我们需要处理各种事件,例如响应按钮的点击,监听键盘的输入,监听网络回包等…我们通常使用<code>Cocoa</code>推荐的例如<code>target-action</code>、<code>delegate</code>、<code>key-value observing</code>、<code>callback</code>等。</li><li><strong>ReactiveCocoa</strong>为我们提供了一种统一化的解决此类问题的方式,使用RAC解决问题，就不需要考虑调用顺序，直接考虑结果，把每一次操作都写成一系列嵌套的方法中，使代码高聚合，方便管理。</li><li><strong>ReactiveCocoa</strong>将所有<code>Cocoa</code>中的事件都定义为了信号(single)，从而可以使用一些基本工具来更容易的连接、过滤和组合.</li></ul><h3 id="RAC中涉及到的编程思想"><a href="#RAC中涉及到的编程思想" class="headerlink" title="RAC中涉及到的编程思想:"></a>RAC中涉及到的编程思想:</h3><ul><li><p><strong>函数式编程</strong>（<a href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="noopener">functional programming</a>）：使用高阶函数，例如函数用其他函数作为参数。</p></li><li><p><strong>响应式编程</strong>（<a href="https://en.wikipedia.org/wiki/Reactive_programming" target="_blank" rel="noopener">reactive programming</a>）：关注于数据流和变化传播。不需要考虑事件的调用过程,只需要关注数据的流入和输出.</p></li></ul><blockquote><p> 所以，你可能听说过reactivecocoa被描述为<a href="https://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank" rel="noopener">函数响应式编程</a><a href="https://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank" rel="noopener">FRP</a>框架。<br>其他平台上也有类似的框架例如java的 <strong>RXJava</strong>  swift中的<strong>ReactiveSwif</strong></p></blockquote><ul><li><strong>链式编程</strong> : 是将多个操作（多行代码）通过点号.链接在一起成为一句代码,使代码可读性好。注意点:要想达到链式编程方法的返回值必须是一个(返回值是本身对象的)<code>block</code>),典型代表就是<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener">Masonry</a>框架</li></ul><hr><h3 id="RAC框架的结构-直接略过"><a href="#RAC框架的结构-直接略过" class="headerlink" title="RAC框架的结构(直接略过)"></a>RAC框架的结构(直接略过)</h3><p><img src="http://blog.leichunfeng.com/images/ReactiveCocoa%20v2.5.png" alt></p><h3 id="RAC中重要的类"><a href="#RAC中重要的类" class="headerlink" title="RAC中重要的类"></a>RAC中重要的类</h3><h4 id="RAC最重要的类是RACSingle-信号类"><a href="#RAC最重要的类是RACSingle-信号类" class="headerlink" title="RAC最重要的类是RACSingle(信号类)"></a>RAC最重要的类是<strong>RACSingle</strong>(信号类)</h4><ul><li>它本身不具备发送信号的能力，而是交给内部一个订阅者(<code>id &lt;RACSubscriber&gt;</code>)去发出。</li><li>默认一个信号创建出来都是冷信号，即使是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了就会触发</li><li>RACSignal的每个操作都会返回一个RACsignal，这在术语上叫做连贯接口（fluent interface）,从而实现 <code>链式编程</code></li></ul><hr><blockquote><p>所以这里着重介绍一下RACSingle的创建和订阅的实现,从而理解信号的创建以及数据的传递过程</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里用到一个工厂方法将子类实例返回回去</span></span><br><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line"> <span class="keyword">return</span> [RACDynamicSignal createSignal:didSubscribe];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们再来看看子类`RACDynamicSignal`中的具体实现,其实就是吧传递过来的didSubscribe这个block保存起来</span></span><br><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line"> RACDynamicSignal *signal = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line"> signal-&gt;_didSubscribe = [didSubscribe <span class="keyword">copy</span>];</span><br><span class="line"> <span class="keyword">return</span> [signal setNameWithFormat:<span class="string">@"+createSignal:"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法的参数<code>didSubscribe</code>这个block 可以理解为是对信号的描述,<br>上面只是信号的创建过程,上面提到了默认信号被创建出来以后只是冷信号,也就是<strong>didSubscribe</strong>这个block只有当RACSingle调用subscribeNext:方法是才会调用,方法里的subscriber有三种方法,也可以理解为可以发送三种信号分别为:<strong>next</strong>、<strong>error</strong>、<strong>completed</strong>,<br>其中<code>sendNext()</code>是发送我们需要传递的对象,<code>sendError</code>,和<code>sendComplete</code>都会中断信号的订阅.不同的是<code>sendError</code>会传递一个错误值<code>error</code>.一个<code>signal</code>在因<code>error</code>终止或者<code>sendComplete</code>前，可以发送任意数量的<code>next</code>事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock;</span><br></pre></td></tr></table></figure><p>下面我们再来看看:subscribeNext:方法的实现过程:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribeNext:(<span class="keyword">void</span> (^)(id x))nextBlock &#123;</span><br><span class="line"> NSCParameterAssert(nextBlock != <span class="literal">NULL</span>);</span><br><span class="line"> RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock </span><br><span class="line">                                                error:<span class="literal">NULL</span> </span><br><span class="line">                                            completed:<span class="literal">NULL</span>];</span><br><span class="line"> <span class="keyword">return</span> [self subscribe:o];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先创建一个RACSubscriber对象,这个是遵守了RACSubscriber协议的<strong>RACSubscriber *</strong>类型的对象,这个对象会将传递进来的nextBlock保存起来(也是保存成成员变量),当创建对象时候的didSubscribe中的”subscriber”调用sendNext:的时候nextBlock就会被调用! 有点绕,这里只是介绍了其中大概的工作原理,其中还有RACScheduler的参与,这里就不做介绍了..</p><h4 id="RAC为cocoa中的很多类通过分类的形式快速生成信号以及常见的宏使用"><a href="#RAC为cocoa中的很多类通过分类的形式快速生成信号以及常见的宏使用" class="headerlink" title="RAC为cocoa中的很多类通过分类的形式快速生成信号以及常见的宏使用:"></a>RAC为cocoa中的很多类通过分类的形式快速生成信号以及常见的宏使用:</h4><p><strong>@weakify(self) &amp; @strongify(self)</strong>: <em>Weak &amp; Strong dance</em></p><p><strong>RACObserve(TARGET, KEYPATH) &amp; RAC(TARGET, …)</strong> :这对宏简直是绝配类似<strong>KVC</strong>的用法,能够快速地实现对象属性的映射</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//e.g.</span><br><span class="line">RAC(self.titleLabel,text) = [RACObserve(self.viewModel, title);</span><br></pre></td></tr></table></figure><p><strong>rac_signalForSelector</strong> : 执行某一个方法就会生成信号</p><p><strong>rac_valuesAndChangesForKeyPath</strong>：用于监听某个对象的属性改变。</p><p><strong>rac_signalForControlEvents</strong>:替代<em>UIControl</em>中的<em>Target</em>模式</p><p><strong>rac_addObserverForName</strong>用于监听某个通知。</p><p><strong>RACTuplePack(…)</strong>快速包装成元祖类,成对出现的有RACTupleUnpack(…)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RACTuple *tuple = RACTuplePack(@&quot;xmg&quot;,@20); </span><br><span class="line">RACTupleUnpack(NSString *name,NSNumber *age) = tuple;</span><br></pre></td></tr></table></figure><p><strong>rac_liftSelector:withSignalsFromArray:Signals:</strong></p><blockquote><p>应用场景: 当界面有多个请求的时候,当所有的请求都回包时才出发某个操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;  RACSignal *request1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">&gt;      // 发送请求1 ,并且获取到数据以后:</span><br><span class="line">&gt;     [subscriber sendNext:@&quot;发送请求1&quot;];</span><br><span class="line">&gt;      return nil; </span><br><span class="line">&gt; &#125;];</span><br><span class="line">&gt;  RACSignal *request2 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">&gt;      // 发送请求2 ,并且获取到数据以后:</span><br><span class="line">&gt;     [subscriber sendNext:@&quot;发送请求2&quot;];</span><br><span class="line">&gt;      return nil; </span><br><span class="line">&gt; &#125;]; </span><br><span class="line">&gt; // 使用注意：updateUIWithR1::中的参数和信号所传递过来的数据一一对应</span><br><span class="line">&gt;  [self rac_liftSelector:@selector(updateUIWithR1:r2:) withSignalsFromArray:@[request1,request2]];</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="RACSubject类"><a href="#RACSubject类" class="headerlink" title="RACSubject类"></a>RACSubject类</h4><ul><li><p><em>RACSubject</em>既是信号(继承自<em>RACSingle</em>类),又是订阅者(遵循<code>&lt;RACSubscriber&gt;</code>),通常使用<em>RACSubject</em>类来代替代理,其实我感觉代替通知都可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">[subject subscribeNext:^(id x) &#123; </span><br><span class="line">   NSLog(@&quot;第一个订阅者%@&quot;,x); </span><br><span class="line">&#125;];</span><br><span class="line">[subject subscribeNext:^(id x) &#123;</span><br><span class="line">   NSLog(@&quot;第二个订阅者%@&quot;,x); </span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@&quot;1&quot;];</span><br></pre></td></tr></table></figure></li><li><p><em>RACReplaySubject</em>:重复提供信号类，RACSubject的子类。</p></li></ul><p><strong><em>RACReplaySubject与RACSubject区别</em></strong>: RACReplaySubject可以先发送信号，在订阅信号，RACSubject就不可以。如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。</p><h4 id="RAC中的集合类RACSequence"><a href="#RAC中的集合类RACSequence" class="headerlink" title="RAC中的集合类RACSequence"></a>RAC中的集合类RACSequence</h4><p><strong>RACSequence</strong>是RAC中的集合类,可以实现OC对象与信号中传递值之间的转换,RAC类库中提供了NSArray,NSDictionary等集合类的分类供其转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//遍历数组</span><br><span class="line">NSArray *numbers = @[@1,@2,@3,@4]; </span><br><span class="line">[numbers.rac_sequence.signal subscribeNext:^(id x) &#123;</span><br><span class="line">     NSLog(@&quot;%@&quot;,x);</span><br><span class="line"> &#125;];</span><br><span class="line"></span><br><span class="line">//遍历字典</span><br><span class="line">NSDictionary *dict = @&#123;@&quot;name&quot;:@&quot;qdaily&quot;,@&quot;age&quot;:@3&#125;;</span><br><span class="line"> [dict.rac_sequence.signal subscribeNext:^(RACTuple *x) &#123; </span><br><span class="line">       RACTupleUnpack(NSString *key,NSString *value) = x; </span><br><span class="line">       NSLog(@&quot;%@ %@&quot;,key,value); </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p><strong>RACTupleUnpack</strong>将RACTuple进行解包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//使用map方法可以快速进行字典转模型</span><br><span class="line">NSArray *flags = [[dictArr.rac_sequence map:^id(id value) &#123;</span><br><span class="line">     return [FlagItem flagWithDict:value]; </span><br><span class="line">&#125;] array];</span><br></pre></td></tr></table></figure><h4 id="RACCommand-RAC中用于处理事件的类"><a href="#RACCommand-RAC中用于处理事件的类" class="headerlink" title="RACCommand:RAC中用于处理事件的类"></a>RACCommand:RAC中用于处理事件的类</h4><blockquote><p>可以理解为命令类,是对信号和事件的封装</p></blockquote><p>使用场景:监听按钮点击，网络请求<br><em>RACCommand</em>使用注意点:</p><ol><li>signalBlock必须要返回一个信号，不能传nil. </li><li>如果不想要传递信号，直接创建空的信号[RACSignal empty]; </li><li>RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。 </li><li>RACCommand需要被强引用，否则接收不到RACCommand中的信号，因此RACCommand中的信号是延迟发送的。</li></ol><p>RACCommand简单使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> RACCommand *requestCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123;</span><br><span class="line">     NSLog(@&quot;请求数据ing...&quot;); </span><br><span class="line">    //这里即使不需要传递值也要创建空的信号而不能返回nil</span><br><span class="line">    //    return [RACSignal empty]; </span><br><span class="line">     return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@&quot;请求数据&quot;];</span><br><span class="line">         // 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。 </span><br><span class="line">        [subscriber sendCompleted]; return nil; </span><br><span class="line">    &#125;];</span><br><span class="line"> &#125;];</span><br><span class="line"> // 强引用命令，不要被销毁，否则接收不到数据,这个command属性一般暴露给外界</span><br><span class="line"> _conmmand = command;</span><br><span class="line"></span><br><span class="line">//下面通常是外面调用</span><br><span class="line"> [command.executionSignals subscribeNext:^(id x) &#123; </span><br><span class="line">    [x subscribeNext:^(id x) &#123;</span><br><span class="line">         NSLog(@&quot;网络获取的值是:%@&quot;,x);</span><br><span class="line">     &#125;];</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// RACCommand高级用法 </span><br><span class="line">// switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号 [command.executionSignals.switchToLatest subscribeNext:^(id x) &#123;                          </span><br><span class="line">    NSLog(@&quot;%@&quot;,x);</span><br><span class="line"> &#125;];</span><br><span class="line"></span><br><span class="line"> //executing 监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。</span><br><span class="line"> [[command.executing skip:1] subscribeNext:^(id x) &#123; </span><br><span class="line">    if ([x boolValue] == YES) &#123;</span><br><span class="line">         // 正在执行 NSLog(@&quot;正在执行&quot;); </span><br><span class="line">    &#125;else&#123; </span><br><span class="line">        // 执行完成 NSLog(@&quot;执行完成&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure><h4 id="RACMuticastConnection"><a href="#RACMuticastConnection" class="headerlink" title="RACMuticastConnection"></a>RACMuticastConnection</h4><blockquote><p>RACMulticastConnection:用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。</p></blockquote><ul><li><p>普通的订阅信号过程:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   NSLog(@&quot;发送请求&quot;);</span><br><span class="line">   return nil;</span><br><span class="line">&#125;];</span><br><span class="line">// 第一次订阅信号 </span><br><span class="line">[signal subscribeNext:^(id x) &#123;</span><br><span class="line">   NSLog(@&quot;接收数据&quot;); </span><br><span class="line">&#125;]; </span><br><span class="line">//  第二次订阅信号 </span><br><span class="line">[signal subscribeNext:^(id x) &#123;</span><br><span class="line">   NSLog(@&quot;接收数据&quot;);</span><br><span class="line">&#125;]; </span><br><span class="line">// 3.运行结果:打印两次@&quot;发送请求&quot;，也就是每次订阅都会发送一次请求</span><br></pre></td></tr></table></figure></li><li><p>RACMulticastConnection:解决重复请求问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   NSLog(@&quot;发送请求&quot;); </span><br><span class="line">  [subscriber sendNext:@1];</span><br><span class="line">       return nil; </span><br><span class="line">  &#125;]; </span><br><span class="line"></span><br><span class="line">RACMulticastConnection *connect = [signal publish];</span><br><span class="line"></span><br><span class="line">// 注意：订阅信号，也不能激活信号，只是保存订阅者到数组，必须通过连接,当调用连接，就会一次性调用所有订阅者的sendNext: </span><br><span class="line">[connect.signal subscribeNext:^(id x) &#123; </span><br><span class="line">  NSLog(@&quot;订阅者一信号&quot;);</span><br><span class="line">&#125;];</span><br><span class="line">[connect.signal subscribeNext:^(id x) &#123;</span><br><span class="line">   NSLog(@&quot;订阅者二信号&quot;); </span><br><span class="line">&#125;]; </span><br><span class="line">[connect connect];</span><br><span class="line">//运行结果:只会打印一次@&quot;发送请求&quot;</span><br></pre></td></tr></table></figure></li></ul><h3 id="RAC中信号处理的常用方法"><a href="#RAC中信号处理的常用方法" class="headerlink" title="RAC中信号处理的常用方法"></a>RAC中信号处理的常用方法</h3><h4 id="RAC-核心方法绑定bind"><a href="#RAC-核心方法绑定bind" class="headerlink" title="RAC 核心方法绑定bind"></a>RAC 核心方法绑定<code>bind</code></h4><p>对比之前的开发方式是赋值，而用RAC开发，应该把重心放在绑定，也就是在创建一个对象的时候，就绑定好以后想要做的事情，而不是等赋值之后在去做事情。<br>列如：把数据展示到控件上，之前都是重写控件的setModel方法，用RAC就可以在一开始创建控件的时候，就绑定好数据。</p><blockquote><p><strong>注意:</strong>在开发中很少使用<code>bind</code>方法，<code>bind</code>属于RAC中的底层方法，RAC已经封装了很多好用的其他方法，底层都是调用bind，用法比bind简单.</p></blockquote><p>下面例子中要实现当 <em>testField</em> 的文字改变以后每次输出”输出:**“,下面的信号订阅方法底层会转换成bind方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 bind 方法</span></span><br><span class="line">[[_textField.rac_textSignal bind:^RACStreamBindBlock&#123;</span><br><span class="line">        <span class="keyword">return</span> ^RACStream *(<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop)&#123;</span><br><span class="line">            <span class="keyword">return</span> [RACReturnSignal <span class="keyword">return</span>:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"输出:%@"</span>,value]];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//直接订阅信号</span><br><span class="line">[_textField.rac_textSignal subscribeNext:^(id x) &#123; NSLog(@&quot;输出:%@&quot;,x); &#125;];</span><br></pre></td></tr></table></figure><h3 id="过滤信号的操作"><a href="#过滤信号的操作" class="headerlink" title="过滤信号的操作"></a>过滤信号的操作</h3><h4 id="fliter-过滤信号-条件过滤"><a href="#fliter-过滤信号-条件过滤" class="headerlink" title="fliter : 过滤信号(条件过滤)"></a>fliter : 过滤信号(条件过滤)</h4><blockquote><ul><li>通过返回<strong>bool</strong>的方式控制是否接受信号传递过来的值(控制是否调用<code>subscribeNext</code>这个block)</li><li>fliter会将接受的信号通过返回的条件进行筛选,并且生成新的信号供订阅者订阅.</li><li>从fliter的使用中可以看出<code>RAC</code>中对信号的操作都会生成新的信号,以便达到链式编程的目的</li><li>从这点建议在对信号的操作的代码书写规范:每一次操作都应该折行,这样阅读起来更加清晰</li></ul></blockquote><p>本例中要实现当用户名长度大于3的时候输出log</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="keyword">self</span>.usernameTextField.rac_textSignal</span><br><span class="line">     filter:^<span class="built_in">BOOL</span>(<span class="keyword">id</span> value)&#123;</span><br><span class="line">        <span class="built_in">NSString</span>*text = value;</span><br><span class="line">        <span class="keyword">return</span> text.length &gt; <span class="number">3</span>;</span><br><span class="line">&#125;] subscribeNext:^(<span class="keyword">id</span> x)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure><h4 id="ignore"><a href="#ignore" class="headerlink" title="ignore:"></a>ignore:</h4><blockquote><p>忽略某些信号的值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 内部调用filter过滤，忽略掉ignore的值 [[_textField.rac_textSignal ignore:@&quot;1&quot;]     </span><br><span class="line">    subscribeNext:^(id x) &#123;</span><br><span class="line">         NSLog(@&quot;%@&quot;,x); </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="distinctUntilChanged"><a href="#distinctUntilChanged" class="headerlink" title="distinctUntilChanged:"></a>distinctUntilChanged:</h4><blockquote><p>当上一次的值和当前的值有明显的变化就会发出信号, 在开发中，刷新UI经常使用，只有两次数据不一样才需要刷新,提高性能,减少不必要的操作</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[_textField.rac_textSignal distinctUntilChanged] subscribeNext:^(id x) &#123;</span><br><span class="line">   NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="take"><a href="#take" class="headerlink" title="take"></a>take</h4><blockquote><p>从信号发出的值中取前n个</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *signal = [RACSubject subject]; </span><br><span class="line">[[signal take:1] subscribeNext:^(id x) &#123;</span><br><span class="line">     NSLog(@&quot;%@&quot;,x); </span><br><span class="line">&#125;];</span><br><span class="line">[signal sendNext:@1]; </span><br><span class="line">[signal sendNext:@2];</span><br></pre></td></tr></table></figure><h4 id="takeLast"><a href="#takeLast" class="headerlink" title="takeLast:"></a>takeLast:</h4><blockquote><p>取最后N次的信号,前提条件，由于是从信号的后面取,所以订阅者必须调用完成，因为只有完成，就知道总共有多少信号.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *signal = [RACSubject subject];</span><br><span class="line">[[signal takeLast:1] subscribeNext:^(id x) </span><br><span class="line">   NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line">[signal sendNext:@1];</span><br><span class="line">[signal sendNext:@2];</span><br><span class="line">//必须有下一步!</span><br><span class="line">[signal sendCompleted];</span><br></pre></td></tr></table></figure><h4 id="takeUntil-RACSignal"><a href="#takeUntil-RACSignal" class="headerlink" title="takeUntil:(RACSignal *):"></a>takeUntil:(RACSignal *):</h4><blockquote><p>获取信号直到某个信号执行完成</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[_textField.rac_textSignal </span><br><span class="line">    takeUntil:self.rac_willDeallocSignal];</span><br></pre></td></tr></table></figure><h4 id="skip-NSUInteger"><a href="#skip-NSUInteger" class="headerlink" title="skip:(NSUInteger):"></a>skip:(NSUInteger):</h4><blockquote><p>跳过几个信号,不接受。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 表示输入第一次，不会被监听到，跳过第一次发出的信号</span><br><span class="line">[[_textField.rac_textSignal skip:1] subscribeNext:^(id x) &#123;</span><br><span class="line">       NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="switchToLatest"><a href="#switchToLatest" class="headerlink" title="switchToLatest:"></a>switchToLatest:</h4><blockquote><p>用于signalOfSignals（信号的信号），有时候信号也会发出信号，会在signalOfSignals中，获取signalOfSignals发送的最新信号。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *signalOfSignals = [RACSubject subject];</span><br><span class="line">RACSubject *signal = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">// 获取信号中信号最近发出信号，订阅最近发出的信号。</span><br><span class="line">// 注意switchToLatest：只能用于信号中的信号</span><br><span class="line">[signalOfSignals.switchToLatest subscribeNext:^(id x) &#123;</span><br><span class="line"></span><br><span class="line">   NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line">[signalOfSignals sendNext:signal];</span><br><span class="line">[signal sendNext:@1];</span><br></pre></td></tr></table></figure><h4 id="Map"><a href="#Map" class="headerlink" title="Map:"></a>Map:</h4><blockquote><p>(映射) map能够”加工信号传递的值”</p><p>这里的加工信号指的是将上一个next事件传递过来的信号值x进行<strong>加工</strong>或者<strong>转换</strong>成任意的OC对象,通过block返回值返回回去,这个例子中就是将用户名加工成NSNumber值返回回去,所以下一个next事件接收到的值就是NSNumber对象.</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[[[<span class="keyword">self</span>.usernameTextField.rac_textSignal</span><br><span class="line">  map:^<span class="keyword">id</span>(<span class="built_in">NSString</span>*text)&#123;</span><br><span class="line">    <span class="keyword">return</span> @(text.length);</span><br><span class="line">  &#125;]</span><br><span class="line">  filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSNumber</span>*length)&#123;</span><br><span class="line">    <span class="keyword">return</span>[length integerValue] &gt; <span class="number">3</span>;</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(<span class="keyword">id</span> x)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x):</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//test2</span></span><br><span class="line">[[validPasswordSignal</span><br><span class="line">map:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *passwordValid)&#123;</span><br><span class="line">    <span class="keyword">return</span>[passwordValid boolValue] ? [<span class="built_in">UIColor</span> clearColor]:[<span class="built_in">UIColor</span> yellowColor];</span><br><span class="line">&#125;]</span><br><span class="line">subscribeNext:^(<span class="built_in">UIColor</span> *color)&#123;</span><br><span class="line">    <span class="keyword">self</span>.passwordTextField.backgroundColor = color;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="flatten-map-信号的映射"><a href="#flatten-map-信号的映射" class="headerlink" title="flatten map: 信号的映射"></a>flatten map: 信号的映射</h4><blockquote><p>flatten可以对传递过来的信号进行加工,会重新新建一个信号,block中的返回值是一个信号</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> [[_textField.rac_textSignal flattenMap:^RACStream *(id value) &#123;</span><br><span class="line">     return [RACReturnSignal return:[NSString stringWithFormat:@&quot;输出:%@&quot;,value]]; &#125;]</span><br><span class="line">              subscribeNext:^(id x) &#123;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>flattenMap 和 Map 方法的区别:</p><ul><li>flattenMap方法中的block返回值是信号,所以是对信号的加工</li><li>Map 方法中的block的返回值是对象,是对信号传递的变量的加工</li><li>一般如果传递的是对象,使用map,信号传递的是信号就用flattenMap</li></ul><h4 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h4><blockquote><p>聚合: 将多个信号发出的值进行聚合</p></blockquote><p>常用用法:通常使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)combineLatest:(id&lt;NSFastEnumeration&gt;)signals reduce:(id (^)())reduceBlock;</span><br></pre></td></tr></table></figure><p>将多个信号进行聚合,在<code>reduceBlock</code>中将信号传递的<code>值</code>进行整合.这个方法会创建一个新的信号携带整合好的值返回,每次这两个源信号的任何一个产生新值时，reduce block都会执行，block的返回值会发给下一个信号。常见应用场景就是登录界面是否满足登录条件从而控制登录按钮的状态</p><blockquote><p>注意这个方法中的reduceBlock: 这个block是一个返回值为id类型的,也就是说我们将需要聚合的信号携带的值进行加工组合以后一定要返回一个新的对象,combineLatest::这个方法返回的信号会携带这个新对象! 我们再注意看<code>reduceBlock</code>中的参数,参数个数是不确定的,他们和信号中携带的值一一对应,为了实现这个功能RAC中专门有个<code>RACBlockTrampoline</code>类来处理这个逻辑</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"></span><br><span class="line">   [subscriber sendNext:@1];</span><br><span class="line"></span><br><span class="line">   return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"></span><br><span class="line">   [subscriber sendNext:@2];</span><br><span class="line"></span><br><span class="line">   return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *reduceSignal = [RACSignal combineLatest:@[signalA,signalB] reduce:^id(NSNumber *num1 ,NSNumber *num2)&#123;</span><br><span class="line"></span><br><span class="line">  return [NSString stringWithFormat:@&quot;%@ %@&quot;,num1,num2];</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[reduceSignal subscribeNext:^(id x) &#123;</span><br><span class="line"></span><br><span class="line">   NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="ReactiveCocoa操作方法之控制流操作"><a href="#ReactiveCocoa操作方法之控制流操作" class="headerlink" title="ReactiveCocoa操作方法之控制流操作"></a>ReactiveCocoa操作方法之控制流操作</h3><h4 id="doNext"><a href="#doNext" class="headerlink" title="doNext:"></a>doNext:</h4><blockquote><p>执行Next之前，会先执行这个Block</p></blockquote><h4 id="doCompleted"><a href="#doCompleted" class="headerlink" title="doCompleted:"></a>doCompleted:</h4><blockquote><p>执行sendCompleted之前，会先执行这个Block</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; </span><br><span class="line">    [subscriber sendNext:@1];</span><br><span class="line">     [subscriber sendCompleted]; </span><br><span class="line">    return nil;</span><br><span class="line"> &#125;] doNext:^(id x) &#123; </span><br><span class="line">    // 执行[subscriber sendNext:@1];之前会调用这个Block         </span><br><span class="line">    NSLog(@&quot;doNext&quot;);; </span><br><span class="line">&#125;] doCompleted:^&#123;</span><br><span class="line"> // 执行[subscriber sendCompleted];之前会调用这个Block </span><br><span class="line">    NSLog(@&quot;doCompleted&quot;);; &#125;] subscribeNext:^(id x) &#123;     </span><br><span class="line">    NSLog(@&quot;%@&quot;,x);</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure><h3 id="ReactiveCocoa中的线程操作"><a href="#ReactiveCocoa中的线程操作" class="headerlink" title="ReactiveCocoa中的线程操作"></a>ReactiveCocoa中的线程操作</h3><h4 id="deliverOn"><a href="#deliverOn" class="headerlink" title="deliverOn:"></a>deliverOn:</h4><blockquote><p>内容传递切换到指定线程中，副作用在原来线程中,把在创建信号时block中的代码称之为副作用。</p></blockquote><h4 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn:"></a>subscribeOn:</h4><blockquote><p>内容传递和副作用都会切换到指定线程中。</p></blockquote><h3 id="ReactiveCocoa操作方法之时间控制。"><a href="#ReactiveCocoa操作方法之时间控制。" class="headerlink" title="ReactiveCocoa操作方法之时间控制。"></a>ReactiveCocoa操作方法之<strong>时间控制</strong>。</h3><h4 id="timeout："><a href="#timeout：" class="headerlink" title="timeout："></a>timeout：</h4><blockquote><p>超时，可以让一个信号在一定的时间后，自动报错。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">     return nil; </span><br><span class="line">&#125;] timeout:1 onScheduler:[RACScheduler currentScheduler]];</span><br><span class="line"></span><br><span class="line">[signal subscribeNext:^(id x) &#123;</span><br><span class="line">     NSLog(@&quot;%@&quot;,x); </span><br><span class="line">&#125; error:^(NSError *error) &#123; </span><br><span class="line">    // 1秒后会自动调用</span><br><span class="line">     NSLog(@&quot;%@&quot;,error); </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="interval"><a href="#interval" class="headerlink" title="interval"></a>interval</h4><blockquote><p>定时：每隔一段时间发出信号</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[RACSignal interval:1 onScheduler:[RACScheduler currentScheduler]] subscribeNext:^(id x) &#123;</span><br><span class="line">     NSLog(@&quot;%@&quot;,x);</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure><h4 id="delay"><a href="#delay" class="headerlink" title="delay"></a>delay</h4><blockquote><p>延迟发送next。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; </span><br><span class="line">   [subscriber sendNext:@1]; </span><br><span class="line">   return nil;</span><br><span class="line">&#125;] delay:2] subscribeNext:^(id x) &#123; </span><br><span class="line">   NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="ReactiveCocoa操作方法之重复。"><a href="#ReactiveCocoa操作方法之重复。" class="headerlink" title="ReactiveCocoa操作方法之重复。"></a>ReactiveCocoa操作方法之重复。</h3><h4 id="retry"><a href="#retry" class="headerlink" title="retry"></a>retry</h4><blockquote><p>重试 ：只要失败，就会重新执行创建信号中的block,直到成功.</p></blockquote><h4 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h4><blockquote><p>节流:当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> RACSubject *signal = [RACSubject subject]; </span><br><span class="line"> _signal = signal; </span><br><span class="line">    // 节流，在一定时间（1秒）内，不接收任何信号内容，过了这个时间（1秒）获取最后发送的信号内容发出。</span><br><span class="line"> [[signal throttle:1] subscribeNext:^(id x) &#123;             </span><br><span class="line">        NSLog(@&quot;%@&quot;,x); </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><blockquote><p>References:</p><p><a href=":https://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1">MVVM+RAC英文教程</a></p><p><a href>http:\/\/www.jianshu.com\/p\/87ef6720a096</a></p><p><a href>http:\/\/www.cocoachina.com\/ios\/20150123\/10994.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ReactiveCocoa&quot;&gt;&lt;a href=&quot;#ReactiveCocoa&quot; class=&quot;headerlink&quot; title=&quot;ReactiveCocoa&quot;&gt;&lt;/a&gt;ReactiveCocoa&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; cla
      
    
    </summary>
    
      <category term="iOSTips" scheme="http://yincongxiao.top/categories/iOSTips/"/>
    
    
  </entry>
  
  <entry>
    <title>runtime黑魔法-Method Swizzling.md</title>
    <link href="http://yincongxiao.top/2015/07/25/runtime%E9%BB%91%E9%AD%94%E6%B3%95-Method-Swizzling-md/"/>
    <id>http://yincongxiao.top/2015/07/25/runtime黑魔法-Method-Swizzling-md/</id>
    <published>2015-07-25T07:16:36.000Z</published>
    <updated>2019-05-16T11:52:21.688Z</updated>
    
    <content type="html"><![CDATA[<p>#</p><h3 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h3><blockquote><p>场景:我们需要在DEBUG模式下通过打印台知道我们点击跳转的控制器的名字,当然我们可以在自己的<code>baseViewController</code>的<code>viewWillAppear:</code>中进行操作,但是这样我们的所有类都必须继承自这个<code>baseViewController</code>才能得到这个能力,有没有更加面向切面的方式来达到这个效果呢?<code>Method Swizzling</code>!</p></blockquote><p>我们需要做的就是给UIViewController写一个分类可以命名为UIViewController (MethodSwizzling)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function">implementation <span class="title">UIViewController</span> <span class="params">(MethodSwizzling)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">+ (void)load &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">Class class = [self class];</span><br><span class="line"><span class="comment">//get selector of `viewWillAppear`</span></span><br><span class="line">SEL originalSelector = @selector(viewWillAppear:);</span><br><span class="line"><span class="comment">//get selector of `swizzed_viewWillAppear`</span></span><br><span class="line">SEL swizzledSelector = @selector(swizzed_viewWillAppear:);</span><br><span class="line"><span class="comment">//get Method of `viewWillAppear`</span></span><br><span class="line">Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class="line">Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</span><br><span class="line"><span class="comment">// exchange the IMP of the method `viewWillAppear` and `swizzed_viewWillAppear`</span></span><br><span class="line">method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)swizzed_viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">[self swizzed_viewWillAppear:animated];</span><br><span class="line">NSLog(@<span class="string">"viewWillAppear-%@"</span>,self.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//viewWillAppear-ViewController</span></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h4><p>想理解方法交换首先要理解以下几个概念:<code>Method</code>,<code>SEL</code>,<code>IMP</code></p><h5 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h5><ul><li>在+load方法中获取两个方法(Method)</li><li>交换他们的实现(IMP)</li></ul><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点:"></a>注意点:</h4><ul><li>method swizzling的实现要在+ load中而不是在+ initialize方法中,它俩的区别可以看<a href="http://asnail.xyz/2015/07/20/初始化方法-load-和-initialize方法/" target="_blank" rel="noopener">这篇文章</a></li><li>注意我们的swizzled的方法一定要调用自己,而不是调用原方法,而且这个方法我们基本一定要调用!是因为方法的调用实际上是寻找方法实现的过程,正常通过方法名<code>viewWillAppear:</code>去class的方法列表(dispatch_table)中寻找到的是<code>viewWillAppear</code>的IMP实现,但是我们通过<code>method_exchangeImplementations</code>将这两个方法的IMP交换了,所以这里调用<code>swizzed_viewWillAppear:</code>其实是找到了<code>viewWillAppear</code>的实现.</li><li>在类簇中是无法通过method swizzling 的方式进行方法交换的.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#&lt;/p&gt;
&lt;h3 id=&quot;Method-Swizzling&quot;&gt;&lt;a href=&quot;#Method-Swizzling&quot; class=&quot;headerlink&quot; title=&quot;Method Swizzling&quot;&gt;&lt;/a&gt;Method Swizzling&lt;/h3&gt;&lt;blockqu
      
    
    </summary>
    
      <category term="iOSTips" scheme="http://yincongxiao.top/categories/iOSTips/"/>
    
    
  </entry>
  
  <entry>
    <title>初始化方法+ load 和+initialize方法</title>
    <link href="http://yincongxiao.top/2015/07/20/%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95-load-%E5%92%8C-initialize%E6%96%B9%E6%B3%95/"/>
    <id>http://yincongxiao.top/2015/07/20/初始化方法-load-和-initialize方法/</id>
    <published>2015-07-20T02:12:34.000Z</published>
    <updated>2019-05-16T11:52:21.689Z</updated>
    
    <content type="html"><![CDATA[<p>有时候我们希望类先执行某些一次性的初始化操作再使用,NSObject根类中有两个可以实现这种初始化操作的方法,这就是<code>+Load</code>和<code>+initailze</code>方法</p><h4 id="Load"><a href="#Load" class="headerlink" title="+Load"></a>+Load</h4><h5 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h5><p>对于加入运行期系统的每个类以及它的分类来说,必定会调用此方法,而且只会被调用一次,通常是在应用程序启动的时候,执行时机在main函数之前!并且先调用父类的+load再调用子类的.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@implementation FatherClass</span><br><span class="line">+(<span class="keyword">void</span>)load &#123;</span><br><span class="line">    NSLog(@<span class="string">"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface SonClass : FatherClass</span><br><span class="line">@end</span><br><span class="line">@implementation SonClass</span><br><span class="line">+(<span class="keyword">void</span>)load &#123;</span><br><span class="line">    NSLog(@<span class="string">"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"><span class="comment">//输出台:</span></span><br><span class="line">+[FatherClass load]</span><br><span class="line">+[SonClass load]</span><br></pre></td></tr></table></figure><p>如果分类中也实现了该方法,那么先调用本类的再调用分类的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@implementation FatherClass</span><br><span class="line">+(<span class="keyword">void</span>)load &#123;</span><br><span class="line">     NSLog(@<span class="string">"%s,%@"</span>,__func__,self);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@<span class="function">implementation <span class="title">FatherClass</span> <span class="params">(category)</span></span></span><br><span class="line">+(void)load &#123;</span><br><span class="line">    NSLog(@<span class="string">"%s,%@"</span>,__func__,self);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">输出台:</span><br><span class="line"><span class="comment">//+[FatherClass load],FatherClass</span></span><br><span class="line"><span class="comment">//+[FatherClass(category) load],FatherClass</span></span><br></pre></td></tr></table></figure></p><p>如果两个没有继承关系的类都实现了+load方法,那么它的调用顺序取决于谁先被加到运行期环境中<br><img src="/assets/屏幕快照 2017-04-06 上午9.13.34.png" alt><br>上图中的AnyObject类与FatherClass类都继承自NSObject,但是FatherClass先被加入进运行期环境,所以它的+load方法会先被执行.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出台:</span><br><span class="line">+[FatherClass load]</span><br><span class="line">+[SonClass load]</span><br><span class="line">+[AnyObject load]</span><br></pre></td></tr></table></figure></p><h5 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点:"></a>使用注意点:</h5><ul><li><strong>在+load的调用时机,系统还处于”脆弱”状态</strong>,虽然系统的库已经被加载进运行期系统,但是我们自己编写的类,或者引用的其他的类库中的类不一定已经可以使用,所以在+load中要尽量避免初始化其他的对象. 比如下面的代码就是不安全的<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@implementation FatherClass</span><br><span class="line">+(<span class="keyword">void</span>)load &#123;</span><br><span class="line">    NSLog(@<span class="string">"%s"</span>,__func__);</span><br><span class="line">    AnyObject *anyObject = [AnyObject <span class="keyword">new</span>];</span><br><span class="line"><span class="comment">//    use anyObject...</span></span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li></ul><p>当然AnyObject这个类使我们自己写的,我们可能通过Complie Sources知道它加载的顺序(这不是一个好办法),但是是用其他类库我们就不得而知.如果恰好在AnyObject中使用了+load方法来进行某些初始化操作来赋予这个类某些特性,并且这个类被载入的晚,那么这就有问题了.</p><ul><li><strong>+load方法不像普通的方法那样遵循继承规则</strong>,如果一个类本身没有实现+load方法,那么无论其各级超类是否实现此方法系统都不会调动.这句话应该这样理解:正常我们给一个对象或者类发消息,如果这个对象(或类)本身没有实现该方法,那么系统会通过isa指针找到父类的实现.但是+load方法不同,子类如果没有实现该方法那么也不会去父类中找.也就是说你实现了系统就调用,你没实现就算了.但是如果在+load中显式的调用[super load];那么就会去调用父类方法了.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通方法,子类实现</span></span><br><span class="line">@implementation FatherClass</span><br><span class="line">- (<span class="keyword">void</span>)eat &#123;</span><br><span class="line">     NSLog(@<span class="string">"%s,%@"</span>,__func__,self);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation SonClass</span><br><span class="line">- (<span class="keyword">void</span>)eat &#123;</span><br><span class="line">  NSLog(@<span class="string">"%s,%@"</span>,__func__,self);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">SonClass *son = [SonClass <span class="keyword">new</span>];</span><br><span class="line">[son eat];</span><br><span class="line">输出台:</span><br><span class="line"><span class="comment">//-[SonClass eat],&lt;SonClass: 0x600000017970&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子类未实现</span></span><br><span class="line">@implementation FatherClass</span><br><span class="line">- (<span class="keyword">void</span>)eat &#123;</span><br><span class="line">     NSLog(@<span class="string">"%s,%@"</span>,__func__,self);</span><br><span class="line">&#125;</span><br><span class="line">@en</span><br><span class="line">@implementation SonClass</span><br><span class="line">@end</span><br><span class="line">SonClass *son = [SonClass <span class="keyword">new</span>];</span><br><span class="line">[son eat];</span><br><span class="line">输出台:</span><br><span class="line"><span class="comment">//-[FatherClass eat],&lt;SonClass: 0x600000001600&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//+load方法,子类实现</span></span><br><span class="line">@implementation FatherClass</span><br><span class="line">+(<span class="keyword">void</span>)load &#123;</span><br><span class="line">     NSLog(@<span class="string">"%s,%@"</span>,__func__,self);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation SonClass</span><br><span class="line">+(<span class="keyword">void</span>)load &#123;</span><br><span class="line">    NSLog(@<span class="string">"%s,%@"</span>,__func__,self);</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">输出台:</span><br><span class="line"><span class="comment">//+[FatherClass load],FatherClass</span></span><br><span class="line"><span class="comment">//+[SonClass load],SonClass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子类未实现</span></span><br><span class="line">@implementation FatherClass</span><br><span class="line">+(<span class="keyword">void</span>)load &#123;</span><br><span class="line">     NSLog(@<span class="string">"%s,%@"</span>,__func__,self);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation SonClass</span><br><span class="line">@end</span><br><span class="line">输出台:</span><br><span class="line"><span class="comment">//+[FatherClass load],FatherClass</span></span><br></pre></td></tr></table></figure><ul><li><strong>在+load方法中的实现务必精简</strong>,尽量减少里面所执行的操作,因为整个应用在执行+load方法时都会阻塞,如果在+load中进行繁杂的代码,那么应用程序在执行期间就会变得无响应,不要调用可能会加锁的方法.实际上但凡是通过+load方法实现的某些任务,基本上都做得不对,真正的用途仅在于调试程序,比如可以再分类中实现+load来看该分类是否已经正确载入系统中.<br>####+initialize<br>#####调用时机<br>对于每个类来说,该方法会在程序第一次使用该类或者该类的子类时被调用,并且只会调用一次.如果子类没有实现,那么会调用父类的该方法</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类实现</span></span><br><span class="line">@implementation FatherClass</span><br><span class="line">+ (<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">    NSLog(@<span class="string">"%s,%@"</span>,__func__,self);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)eat &#123;</span><br><span class="line">     NSLog(@<span class="string">"%s,%@"</span>,__func__,self);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation SonClass</span><br><span class="line">+ (<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">    NSLog(@<span class="string">"%s,%@"</span>,__func__,self);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">SonClass *son = [SonClass <span class="keyword">new</span>];</span><br><span class="line">[son eat];</span><br><span class="line">输出台:</span><br><span class="line"><span class="comment">//+[FatherClass initialize],FatherClass</span></span><br><span class="line"><span class="comment">//+[SonClass initialize],SonClass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子类不实现</span></span><br><span class="line">@implementation FatherClass</span><br><span class="line">+ (<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">    NSLog(@<span class="string">"%s,%@"</span>,__func__,self);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)eat &#123;</span><br><span class="line">     NSLog(@<span class="string">"%s,%@"</span>,__func__,self);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation SonClass</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">SonClass *son = [SonClass <span class="keyword">new</span>];</span><br><span class="line">[son eat];</span><br><span class="line">输出台:</span><br><span class="line"><span class="comment">//+[FatherClass initialize],FatherClass</span></span><br><span class="line"><span class="comment">//+[FatherClass initialize],SonClass</span></span><br></pre></td></tr></table></figure><p>我们发现子类如果实现了就走子类的方法,子类没有实现就走父类的方法.这与普通的方法是相同的,都遵循集成规则,这个与+load不同.<br>那我们如果不想因为子类而调用到父类的方法该怎么办呢?<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@implementation FatherClass</span><br><span class="line">+ (<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">    <span class="keyword">if</span> (self == [FatherClass class]) &#123;</span><br><span class="line">        NSLog(@<span class="string">"%s,%@"</span>,__func__,self);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">输出台</span><br><span class="line"><span class="comment">//+[FatherClass initialize],FatherClass</span></span><br></pre></td></tr></table></figure></p><h5 id="load与-initalize方法的区别"><a href="#load与-initalize方法的区别" class="headerlink" title="+load与+initalize方法的区别"></a>+load与+initalize方法的区别</h5><ul><li>+initalize 是惰性调用,只有当给该类或者该类的派生类被使用时才会被调用.</li><li>+load方法,应用会阻塞并等待所有类的+load执行完才会继续执行.</li><li>+initalize方法是线程安全的.所以不用担心对该类第一次发消息的线程问题.</li><li>+load不遵循继承规则</li><li>+load方法运行环境不是安全的,但是+initalize方法运行时可以调用任何类的任何方法;</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候我们希望类先执行某些一次性的初始化操作再使用,NSObject根类中有两个可以实现这种初始化操作的方法,这就是&lt;code&gt;+Load&lt;/code&gt;和&lt;code&gt;+initailze&lt;/code&gt;方法&lt;/p&gt;
&lt;h4 id=&quot;Load&quot;&gt;&lt;a href=&quot;#Load&quot; 
      
    
    </summary>
    
      <category term="iOSTips" scheme="http://yincongxiao.top/categories/iOSTips/"/>
    
    
  </entry>
  
  <entry>
    <title>UIView的layoutSubViews</title>
    <link href="http://yincongxiao.top/2015/01/25/UIView%E7%9A%84layoutSubViews/"/>
    <id>http://yincongxiao.top/2015/01/25/UIView的layoutSubViews/</id>
    <published>2015-01-25T07:05:09.000Z</published>
    <updated>2019-05-16T11:52:21.687Z</updated>
    
    <content type="html"><![CDATA[<p>本文包含了<code>UIView</code>中<code>layoutSubviews</code>,<code>setNeedsLayout</code>,<code>layoutIfNeeded</code>三个常用方法的调用时机.以后还会有其他方法的研究补充.</p><h3 id="layoutSubviews"><a href="#layoutSubviews" class="headerlink" title="layoutSubviews"></a>layoutSubviews</h3><p>UIView中的<code>layoutSubviews</code>方法本身实际上并没有做什么事情,而是需要交给子view去复写,顾名思义我们应该在这个方法中调整(布局)子view,我们只有充分了解该方法的调用时机,才能知道某些调整是不是应该写到这个方法中.<br>经过实例验证<code>layoutSubviews</code>的调用时机有以下几个情况:</p><ul><li>初始化的时候是不会调用<code>layoutSubviews</code>,view被添加到父view上的时候,并且view的frame不是<code>CGRectZero</code>才会调用<code>layoutSubviews</code>!</li><li>view的<code>size</code>(注意是size)发生改变的时候.如果只改变位置而size没发生改变是不会调用<code>layoutSubviews</code> 方法的,想想这也完全合理.</li><li>屏幕旋转的时候会调用,<code>window</code>-&gt;<code>rootVC</code>-&gt;<code>rootVC.SubViews</code></li><li>调用<code>addSubView:</code>方法</li><li><code>UIScrollView</code>在滑动的时候会频繁调用<code>layoutSubviews</code></li></ul><p>下面我们就逐个验证一下,加深一下记忆.往下看会有意想不到的收货哦.<br>首先我们创建一个view取名为<code>ParentView</code>继承自<code>UIView</code><br>仅仅是打印一下方法的执行.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)layoutSubviews &#123;</span><br><span class="line">[super layoutSubviews];</span><br><span class="line">NSLog(@<span class="string">"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在vc中</p><h5 id="view被add到父view上"><a href="#view被add到父view上" class="headerlink" title="view被add到父view上"></a>view被add到父view上</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">ParentView *pv = [[ParentView alloc] initWithFrame:CGRectMake(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">50</span>)];</span><br><span class="line">pv.backgroundColor = [UIColor redColor];</span><br><span class="line">[self.view addSubview:pv];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-[ParentView layoutSubviews]</span></span><br></pre></td></tr></table></figure><p>有打印,说明view被加到父view上确实调用了<code>layoutSubviews</code>方法,但是我们把初始化的frame改为<code>CGRectZero</code>,那么没有打印,说明<strong>view的frame不为CGRectZero才会调用layoutSubviews</strong><br>我们把<code>[self.view addSubview:pv];</code>注释掉以后就没有打印,所以<strong>初始化不会调用layoutSubviews!</strong></p><h5 id="setNeedsLayout"><a href="#setNeedsLayout" class="headerlink" title="setNeedsLayout"></a>setNeedsLayout</h5><p><code>setNeedsLayout</code>方法:给view加上需要刷新的标记,异步的去调用<code>layoutIfNeeded</code>,从而去调用<code>layoutSubviews</code>(关于<code>layoutIfNeeded</code>方法下文会具体分析)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">[_pv setNeedsLayout];</span><br><span class="line">NSLog(@<span class="string">"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-[ViewController touchesBegan:withEvent:]</span></span><br><span class="line"><span class="comment">//-[ParentView layoutSubviews]</span></span><br></pre></td></tr></table></figure></p><p>发现每次点击都会调用,说明<code>layoutSubviews</code>确实会触发view的<code>layoutSubviews</code>,注意这里是<strong>异步</strong>调用,所以并不是在调用<code>setNeedsLayout</code>的时刻去调用<code>layoutSubviews</code>,而是在下一个runloop循环处理该事件,所以打印顺序是这样的!</p><p>注意: addSubView其实是隐式得调用了<code>setNeedsLayout</code>方法,我们来验证一下<br>在<code>addSubview</code>后加一句打印</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[self.view addSubview:_pv];</span><br><span class="line">NSLog(@<span class="string">"addSubview"</span>);</span><br><span class="line"><span class="comment">// addSubview</span></span><br><span class="line"><span class="comment">//-[ParentView layoutSubviews]</span></span><br></pre></td></tr></table></figure><p>先调用的addSubview再异步调用layoutSubviews.</p><h5 id="layoutIfNeeded"><a href="#layoutIfNeeded" class="headerlink" title="layoutIfNeeded"></a>layoutIfNeeded</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">[_pv layoutIfNeeded];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现并不会打印,<code>layoutIfNeeded</code>:调用该方法会首先查看该view是不是具有<em>需要重新布局的标志</em>(是否调用过<code>setNeedsLayout</code>方法).如果有标记那么就去调用<code>layoutSubviews</code>,如果没有那么什么都不做!<br>tip:我们如果想立马重新排版那么可以组合使用这两个方法.通常我们只需要调用<code>setNeedsLayout</code>就能达到要求.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[_pv setNeedsLayout];</span><br><span class="line">[_pv layoutIfNeeded];</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">[_pv setNeedsLayout];</span><br><span class="line">[_pv layoutIfNeeded];</span><br><span class="line">NSLog(@<span class="string">"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-[ParentView layoutSubviews]</span></span><br><span class="line"><span class="comment">//-[ViewController touchesBegan:withEvent:]</span></span><br></pre></td></tr></table></figure><p>看打印顺序发生了改变;</p><h5 id="改变-view-的frame"><a href="#改变-view-的frame" class="headerlink" title="改变 view 的frame"></a>改变 view 的frame</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">_pv.frame = CGRectMake(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们直接设置为原来的frame,发现也不会打印<code>layoutSubviews</code>,后来验证得出结论: <strong>view的<code>size</code>(注意是size)发生改变的时候才会调用<code>layoutSubviews</code>.如果只改变位置而size没发生改变是不会调用<code>layoutSubviews</code> 方法的,想想这也完全合理</strong></p><h5 id="旋转屏幕"><a href="#旋转屏幕" class="headerlink" title="旋转屏幕"></a>旋转屏幕</h5><p>通过真机测试,我这里得到这样一个结论(很费解):</p><ul><li>UIView没有子view,旋转屏幕并不会调用它的<code>layoutSubviews</code>方法</li><li>UIView有子view并且子view不是<code>UIView</code>类型的(UIView的子类例如UIButton,UILabel,UIImageView,UIScrollView等)会调用两次<code>layoutSubviews</code>方法.</li></ul><h5 id="UIScrollView的layoutSubviews"><a href="#UIScrollView的layoutSubviews" class="headerlink" title="UIScrollView的layoutSubviews"></a>UIScrollView的layoutSubviews</h5><p>在这里我们只是将<code>ParentView</code>父类改变为<code>UIScrollView</code>,我发现<code>addSubView:</code>调用的时候会调用两次<code>layoutSubviews</code>,而普通的UIView只会调用一次.并且给他设置一个contentSize,当滑动的时候确实会多次调用<code>layoutSubviews</code>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文包含了&lt;code&gt;UIView&lt;/code&gt;中&lt;code&gt;layoutSubviews&lt;/code&gt;,&lt;code&gt;setNeedsLayout&lt;/code&gt;,&lt;code&gt;layoutIfNeeded&lt;/code&gt;三个常用方法的调用时机.以后还会有其他方法的研究补充.&lt;/
      
    
    </summary>
    
      <category term="iOSTips" scheme="http://yincongxiao.top/categories/iOSTips/"/>
    
    
  </entry>
  
</feed>
