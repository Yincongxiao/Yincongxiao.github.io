<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="希望自己在未来的路上越走越坚定."><title>iOS 和 MacOSX 中的内存管理 | aSnail</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS 和 MacOSX 中的内存管理</h1><a id="logo" href="/.">aSnail</a><p class="description">年轻就是折腾</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS 和 MacOSX 中的内存管理</h1><div class="post-meta">Jul 8, 2019</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#iOS-和-MacOSX-中的内存管理"><span class="toc-number">1.</span> <span class="toc-text">iOS 和 MacOSX 中的内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟内存"><span class="toc-number">1.0.1.</span> <span class="toc-text">虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#在iOS中内存是如何创建并管理的"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">在iOS中内存是如何创建并管理的?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clean-amp-dirty-memory"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">clean &amp; dirty memory</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存紧张时系统如何处理"><span class="toc-number">1.0.2.</span> <span class="toc-text">内存紧张时系统如何处理</span></a></li></ol></li></ol></div></div><div class="post-content"><h1 id="iOS-和-MacOSX-中的内存管理"><a href="#iOS-和-MacOSX-中的内存管理" class="headerlink" title="iOS 和 MacOSX 中的内存管理"></a>iOS 和 MacOSX 中的内存管理</h1><p>为什么想到聊内存管理,是因为最近做了一个APM相关的SDK,其中需要采集app内存使用情况,其中有很长一段时间的探索过程,这篇就是过程中回顾到的一些知识,在此记录一下.<br>谈到iOS中的内存管理,大家可能首先想到的是ARC,确实编译器帮我们完成了大部分开发中需要注意的内存问题,但是理解内存管理对我们开发很有帮助,不仅可以帮助我们提高app内存表现,还能在一定程度上释放CPU的压力.还可以为开发中遇到的各种各样的内存问题诸如<code>爆内存</code>,<code>内存泄露</code>,<code>坏内存访问</code>等等疑难杂症提供解决思路.</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p><strong>什么是虚拟内存</strong><br>因为同时运行在操作系统上的进程是很多的,环境非常复杂,如果所有软件都直接向物理内存中申请内存,那很容易导致其他应用出现问题,甚至可能将操作系统搞挂,还有一个问题是物理内存空间通常是比较有限的,写程序如果在一个有限的环境下那会导致很多功能无法实现,还有很多很多其他的问题.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">All problems in computer science can be solved by another level of indirection – David Wheeler </span><br><span class="line">计算机科学中的任何问题，都可以通过加上一层逻辑层来解决。– David Wheeler</span><br></pre></td></tr></table></figure>
<p>为了解决这些问题计算机科学引入了虚拟内存,虚拟内存为所有应用程序统一管理应用内存的分配和释放</p>
<p>在iOS和OSX系统内部都有全套完整的虚拟内存系统,虚拟内存将进程完美的分开,对每个进程来说好像是独立拥有手机的全部内存空间一样,对于32位系统来说你拥有<code>2^32</code>也就是4GB的虚拟内存控件可以操作,对于64位系统来说有18eb.<br><img src="https://s.momocdn.com/w/u/others/2019/07/03/1562147360475-vm_address.jpg" alt></p>
<h4 id="在iOS中内存是如何创建并管理的"><a href="#在iOS中内存是如何创建并管理的" class="headerlink" title="在iOS中内存是如何创建并管理的?"></a>在iOS中内存是如何创建并管理的?</h4><p><img src="https://s.momocdn.com/w/u/others/2019/07/03/1562146976883-VM_graph.jpg" alt></p>
<p><strong>虚拟内存中的细节</strong></p>
<p><strong>分片(page)&amp;pagging</strong><br>在操作系统内存管理中,片(page)是内存管理的最小单元,无论是物理内存还是虚拟内存都按照一个个连续的片分割开来,在iOS4之前一个page的大小为4kb,iOS4之后的系统都是16kb/page,我们创建一个对象,系统会为我们分配一个page或者若干个page.<br>当我们在代码中使用malloc申请一段内存时,其实操作系统只是在虚拟内存中帮我们申请了指定大小的内存,并没有去物理内存中申请,当我们向申请的这段内存写数据时,<br>,我们试图去向第一片内存中写数据时,</p>
<div><img align="center" height="400" weight="100" src="https://s.momocdn.com/w/u/others/2019/07/02/1562067642575-Xnip2019-07-02_19-39-52.jpg"></div>

<h4 id="clean-amp-dirty-memory"><a href="#clean-amp-dirty-memory" class="headerlink" title="clean &amp; dirty memory"></a>clean &amp; dirty memory</h4><p>我们将内存page的状态分为两种:<br>clean memory: 基于 readonly 文件而被加载到内存中的Page称为 clean memory，比如：系统 framework、可执行文件、通过 mmap 方式读取的文件等。这种 Page 由于是加载自不可变的文件，因此可以在物理内存紧张时被 iOS 自动 unload 出去，并且在需要的时候再重新从原来的文件加载到内存中。<br>dirty memory:凡是非 clean 的 Page 都是 dirty 的，它们的共同特点是 Page 在disk中没有对应的文件，比如通过 alloc 在堆上创建的内存空间，已经解压的图片，database caches 等.dirty memory 不能被操作系统交换出去，只有在进程被杀死的时候才能被回收，因此在系统发生内存告警时，如果进程创建了大量的 dirty memory，那么将很有可能被 kill 掉。</p>
<p>怎样判断我们申请的内存时clean的还是dirty的呢?来看下面的例子顺便详细说明虚拟内存的工作原理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  <span class="keyword">int</span> *intArr = <span class="built_in">malloc</span>(<span class="number">20000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="number">2.</span>  intArr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="number">3.</span>  intArr[<span class="number">1999</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>在上面代码中,当我们使用malloc函数申请一段内存时,虚拟内存是怎么工作的呢?<br>系统在执行到第1行代码时,虽然我们向系统申请了<code>20000 * sizeof(int)</code>长度的内存,系统只是在虚拟内存中帮我们分配了6页内存页,这些内存页并没有与物理内存中的page建立映射,这样的页为<code>clean memory</code>,在执行到第2行代码时操作系统发现这段在虚拟内存中的页并没有映射到物理内存中,那么此时就会触发一个<a href="https://zh.wikipedia.org/wiki/%E9%A1%B5%E7%BC%BA%E5%A4%B1" target="_blank" rel="noopener">页错误</a>,然后操作系统通过<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83" target="_blank" rel="noopener">MMU</a>单元计算出物理内存地址,然后操作系统会在物理内存中申请内存,返回给应用程序,此时也就将此片虚拟内存和物理内存建立了映射,这个过程称为<code>pagging</code>.在iOS中我们称这样的内存片为<code>dirty memory</code>.<br>当执行完第3行代码时,系统会将第6片内存页映射到物理内存,这片内存也变成dirty,而中间1998个内存片依然是clean的.</p>
<p>再来看下面的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *helloWordStr = [NSString stringWithUTF8String:&quot;hello word&quot;];</span><br><span class="line">NSString *helloWordStr2 = @&quot;hello word&quot;;</span><br></pre></td></tr></table></figure></p>
<p>对于helloWordStr,因为这个方法会把字符串常量拷贝到堆区,所以是dirty,而下面的helloWordStr2在DATA段,这部分的数据是readonly的,所以它是clean的.<br>还有类似<code>[UIImage imageNamed:@&quot;&quot;];</code>以及<code>core graph</code>中的方法创建出来的图片都是dirty memory.我们app中大部分的操作产生的都是dirty memory</p>
<h3 id="内存紧张时系统如何处理"><a href="#内存紧张时系统如何处理" class="headerlink" title="内存紧张时系统如何处理"></a>内存紧张时系统如何处理</h3><p>在macOS中有置换机制,使用磁盘来为RAM”扩容”,但是在iOS中没有这个机制.iOS只能尝试去将dirty memory清理一部分, iOS7之后还引入了memory compress技术,简单那来说就是在内存不足时系统可以把一部分dirty内存压缩,这样就能腾出一部分空间,系统也会给进程发送memorywarnning通知,如果app没有及时处理系统就会先把后台进程杀掉,所以如果我们app申请过大内存也影响其他app的体验,通过杀掉后台app系统已经腾出一部分空间出来,但是如果进程继续申请很多内存,系统只能把前台app也杀掉.</p>
<p>怎样防止app被kill掉呢,我们要注意减少dirty memory的使用.</p>
<p>我们通常所说的footprint memory就是dirty + complessed memory.</p>
<div><img height="400" weight="100" src="https://s.momocdn.com/w/u/others/2019/07/04/1562227277284-foot_print.jpg"></div><br>注意在清理缓存的过程中有一个陷阱:下面举例说明<br>有这样一个场景我使用一个<code>NSMutableDictionary *</code>对象缓存了一些数据,收到内存警告时我把我的缓存中的对象全部清除<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning &#123;</span><br><span class="line">    [self.cacheDict removeAllObjects];</span><br><span class="line">    [super didReceiveMemoryWarning];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>很遗憾的是这个看似比较负责的做法可能会适得其反,因为有memory compress 的存在,所以在内存紧张时我的cache中的数据可能已经被压缩了一部分例如下面图<br><br><div><img height="100" weight="400" src="https://s.momocdn.com/w/u/others/2019/07/04/1562227307649-compressed_dic.jpg"></div>

<p>但是当内存警告时我试图清理掉他们,然后访问这些数据,结果内核会将这个压缩的内存解压缩给我们用,导致dirty memory直线上升,很可能因为这样的操作导致app提前被kill.</p>
<div><img height="100" weight="400" src="https://s.momocdn.com/w/u/others/2019/07/04/1562227284619-compless_fail.jpg"></div><br>这不是我们想看到的.应该怎么做呢,如果我们使用了NSDictionary,NSArray等容器,等收到memory warining时一定要小心处理缓存,我们尽量去不再申请更多的内存,而不是去碰这些内存.系统提供了NSPurgeableDataw我们可以使用这个数据来封装我们的缓存数据<br>另一个比较好的方式直接使用NSCache容器,NSCache相较NSDictionary有很多优点<br>1. 它是线程安全的<br>2. 缓存到NSCache中的数据是Purgeable的,当发生内存紧张时系统可以释放他们腾出空间.<br>3. NSCache不会拷贝key.<br>4. 在清理策略上也是具有LRU策略,总之在典型的内存缓存场景下NSCache很多优势.<br><br>另外在app退后台时可以在不影响用户体验的情况下尽可能多的释放内存,这样可避免在后台时被杀死,<a href="https://github.com/Split82/iOSMemoryBudgetTest" target="_blank" rel="noopener">这个demo</a>可以测试你的机型极限情况下可以申请的内存最大数量,<a href="https://stackoverflow.com/questions/5887248/ios-app-maximum-memory-budget" target="_blank" rel="noopener">这个问题</a>列举了一些人做的实验可以作为一些参考.<br><br><strong>wired memory</strong><br>wired memory 又称为resident memory,是操作系统内核或者其他不能被pagging out的内存,用户空间是不能申请wired memory的,但是用户空间的行为可以影响wired memory,比如程序通过创建线程或者mach port等来隐式的增大 wired memory.比如一个正常的而线程大概占用5个字节的wired memory,一个被阻塞的线程大概占用21个字节的空间.<br>每一个线程,进程,port,后者二进制库都会影响wired memory的大小,系统内核需要使用wired memory来做一下几个事情: vm_object, 虚拟内存缓存,驱动,io缓存.系统需要使用维护虚拟内存和物理内存的映射关系,所以当你申请一段内存时没有进行定其他操作wired memory也会增加.<br>在 mac中只打开finder一个应用,如果你的电脑内存有64M内存,就会有大约14M<code>wired memory</code>,如果你是128M内存的电脑,大约有17M<code>wired memroy</code>.<br>wired memory在不使用时并不会马上变成空间内存,而是当空闲内存少于阈值时触发系统pagging out时才会被回收.<br><br>### OSX中的内存管理<br>#### pagging in &amp; pagging out<br><br>当内存可用空间不足时,操作系统会采取一些措施以腾出可用空间,这个具体操作根据系统不同而不同,在OSX中会将内存中的page交换到磁盘中的<code>backing store</code>中,<code>backing store</code>是一片用来存放置换片的磁盘空间.这个置换过程称之为<code>pagging out</code>.当程序访问这些已经置换到磁盘的内存片时,操作系统就会将这些page从<code>backing store</code>置换到内存中,这个过程称之为<code>pagging in</code>.系统在进行page in 或者page out时性能通常不好,所以每个OSX中的app开发者都应该尽量减少太多内存的申请,下面会具体介绍pagging out 和pagging in的过程.<br><br>操作系统将物理内存中的page根据状态记录在三个队列中:<br>active list: 这部分page已经映射到虚拟内存中,并且最近访问过<br>inactive list: 这部分page已经映射到虚拟内存中,但是最近没有访问过<br>free list: 这部分page 有映射到虚拟内存,可以随时被进程使用.<br><br><strong>pagging out</strong><br>当系统free list中的page count低于设定阈值时(这个阈值根据物理内存的大小决定),操作系统会调整三个列表,以腾出内存空间来<br>在active list中的内存片如果长时间没有访问,那么内核就会将这部分内存片放到inactive list 中.<br>在inactive list中的内存片如果长时间没有访问,那么内核尝试根据这个page的vm_object查看该片段中的内存是不是被置换到磁盘中过,如果没有被置换到磁盘中过,内核生成一个pager对象,pager对象会将这个内存片置换到磁盘的<code>backing store</code>中,如果pager置换成功了就将这个腾出来的内存片放到free list中.<br>如果一个在inactive list中的内存段最近没有访问过,并且这部分内存不是wired memory,内核将这个内存片与虚拟内存的关联取消,并且抹掉放到free list中.一旦free list达到了阈值那么这个过程就会停止.<br>这点在iOS系统中是不同的,(iOS中这部分inactive list中的page并不会置换到磁盘中,而是交给使用这部分内存的应用清理,触发memory warnning).应用程序手动清理内存以后,内核就会把这部分内存片放到free list中.<br><br><strong>pagging in</strong><br>当程序试图访问虚拟内存中的内存片时,如果该内存片没有和物理内存中建立映射,那么就会发生页错误,页错误分为软错误和硬错误两种<br>软错误: 程序试图访问的内存地址在物理内存中有,但是并没有和程序的虚拟内存系统建立映射关系<br>硬错误: 程序试图访问的内存地址在物理内存中没有,已经被交换或者被映射在mmap文件中<br>当遇到页错误时内核首先会定位这个内存片所在的region中,找到相关的vm object,然后查找vm object中的resident list,如果resident list中有想访问的内存片,那么就将这个页错误归为软错误,否则归为硬错误.<br>对于软错误,系统将这个物理内存片和虚拟内存地址关联起来,并且给这个内存片放到active list中.<br>对于硬错误,内核在磁盘的backing store中找到这个内存片,将这个内存片写到物理内存中,并且将这个内存片放到active list中.<br><br>讲了这么多其实在iOS中是没有<code>pagging out</code>机制的,但是在某些特性情况下一些只读数据是可以发生<code>pagging in</code>的.<br><br><strong>mmap</strong><br>通常我们访问磁盘中的一个文件需要将文件首先读到内存中,操作完毕再将内存中的文件写入磁盘,其中的读取是有拷贝操作.系统提供了mmap()函数可以允许进程直接对磁盘中的文件建立映射关系,进程可以像读写内存一样对普通文件的操作,该文件的销毁由系统接管,比read少了一次拷贝操作,因此性能更好,在读取磁盘大文件中的一部分这种场景下有突出的优势,基于这个优势可以写一个高效率的写文件工具.<br><div><img height="400" weight="100" src="https://s.momocdn.com/w/u/others/2019/07/03/1562127792223-mmap.jpg"></div>

<p>mmap的另一个重要用法是实现进程间文件的共享,感兴趣可以自行google</p>
<p>参考文章:</p>
<ul>
<li><a href="https://developer.apple.com/videos/play/wwdc2018/416/?time=134" target="_blank" rel="noopener">WWDC_2018_416_trim your footprint</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html#//apple_ref/doc/uid/20001880-99100-TPXREF113" target="_blank" rel="noopener">AboutMemory</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/vm/vm.html#//apple_ref/doc/uid/TP30000905-CH210-CHDEDGCA" target="_blank" rel="noopener">Kernel Programming Guide</a></li>
<li><a href="https://forums.developer.apple.com/thread/105088" target="_blank" rel="noopener">talking about memory access</a></li>
<li>&lt;&lt;深入理解计算机系统&gt;&gt;</li>
</ul>
</div><div class="tags"></div><div class="post-nav"><a class="next" href="/2019/05/23/关于AMP/">关于AMP</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  id: window.location.pathname.substring(1,window.location.pathname.length),
  owner: 'Yincongxiao',
  repo: 'https://github.com/Yincongxiao/comments.git',
  oauth: {
    client_id: 'f0ad4ed067ce7fbb434e',
    client_secret: '7087f062d22963283c4bc2bdaa350163946c0fa0',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yincongxiao.top"></form></div><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="http://yincongxiao.top"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOSTips/">iOSTips</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS源码分析/">iOS源码分析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/CoreAnimation/" style="font-size: 15px;">CoreAnimation</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/07/08/iOS-和-MacOSX-中的内存管理/">iOS 和 MacOSX 中的内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/关于AMP/">关于AMP</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/16/Xcode运行python脚本/">Xcode运行python脚本</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/28/Swift4-0/">Swift4.0</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/18/Https简单复习/">Https简单复习.md</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/23/Toll-Free-Bridging/">Toll-Free Bridging</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/20/YYMemeryCache-study/">YYMemeryCache-study</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/15/YYDiskCache-study/">YYDiskCache study</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/02/GCD-dispatch-source/">GCD-dispatch_source</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/10/dispatch-group-t-使用详解/">dispatch_group_t 使用详解</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">aSnail.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>